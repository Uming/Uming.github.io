<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[randomized algorithm]]></title>
    <url>%2F2017%2F12%2F11%2Frandomized-algorithm%2F</url>
    <content type="text"><![CDATA[总结 1. 概率算法 1.1. 概率算法分类 Numerical Monte Carlo 给出一个答案，未必正确 Las Vegas 答案必定正确，耗时任意长 Sherwood 总是给出正确的答案 1.2. 数值积分 HitorMiss 算法，长方形下函数面积，取样 Crude 算法，积分区间函取值的平均. 1.3. 概率计数 求集合 \(X\) 的势 设 \(|X| = n\) , 有放回地随机抽元素, 设 \(k\) 是出现第一次重复之 前所选的元素数目. 则当 \(n\) 足够大时, \(k\) 的期望趋近于 \(\beta \sqrt{n}\) , \(\beta = \sqrt{\pi / 2} \approx 1.253\) 多重集合中不同对象数目的估计, 例如,磁带上记录有莎士比亚全集, 统计其中使用了多少不同的单词. \(N\) 是总单词书, \(n\) 是不同词个数. 设 \(U\) 是单词序列的集合, 设 \(m = 5 + \lceil lg M \rceil\) let \(h : U \mapsto \{0,1\}^m\) be a hash function. 将单词映射为长度为 \(m\) 的串. \(y \in \{0,1\}^k\), \(y[i]\) denotes the \(i\)th bit. Define \(\pi(y, b), b\in \{0,1\}\) 表示满足 \(y[i] = b\) 的最小的 \(i\), 如果不存在, 返回 \(k+1\) 算法 WordCount() 用一个长为 \(m+1\) 的向量\(y\) 统计所有单词的哈希. 单词 \(x\), set \(y[\pi(h(x), 1)]\) to 1 1.3.1. Sherwood 算法 Sherwood 算法, 平滑不同输入实例的执行时间. 例如快排 , 在特定输入下时间复杂度\(O(n^2)\), 可以吧把输入变换到一个随机实例上. 例子: 离散对数的计算. 例子: 搜索有序表 1.3.2. Las Vegas 算法 2. 分布式算法 模型： 异步共享存储 异步msg传递 同步msg传递 拓扑：无向图，节点为处理机，边喂双向信道. 算法：由每个处理器上的局部程序构成，包括本地计算和收发msg 节点 \(p_i\), \(p_i\) 相邻的边 \(r\) 条. \(p_i\) 有两个 buffer list: \(outbuf_i[l]\) , \(inbuf_i[l]\), \(l \in [1, r]\) 配置：某时刻，算法运行的全局状态。为一个向量 \((q_0, \ldots, q_{n-1})\), \(q_i\) 是 \(p_i\) 的状态. 状态 事件：两种 \(comp(i)\), 计算事件. \(del(i,j,m)\), 传递事件，将msg \(m\) 从 \(p_i\) 传递到 \(p_j\). 转换函数 执行: 配置和事件交错的序列。 Safety 条件。 (用来证明算法正确性吗?) 该条件在每个有限前缀里的都成立 Liveness 条件。 必须成立一定次数。 满足所有安全性条件的序列称为一个执行, 满足所有活跃性条件的 执行 为 容许(admissible) 的执行。 下面主要考虑异步msg传递系统。 执行片段 \(\alpha\) 是一个有限或无限的序列: \[ C_0, \Phi_1, C_1, \Phi_2, C_2, \ldots, \] 其中 \(C_k\) 是一个配置, \(\Phi_k\) 是一个事件. 如果 \(\alpha\) 有限, 则它必须结束语某个配置, 且需满足下诉条件: 若 \(\Phi_k = del(i,j,m)\), 则 \(m\) 必须是 \(C_{k-1}\) 时 \(outbuf_i[l]\) 的元素. \(l\) 是 \(p_i\) 信道 \({p_i, p_j}\) 的标号. 从 \(C_{k-1}\) 到 \(C_k\) 的唯一变化是将 \(m\) 从 \(C_{k-1}\) 里的 \(outbuf_i[l]\) 中 删去, 加入到 \(C_k\) 的 \(inbuf_i[h]\), \(h\) 是 \(p_j\) 的信道 \({p_j, p_i}\) 的标号. 若 \(\Phi_k = comp(i)\), 则 \(C_{k-1}\) 到 \(C_k\) 的变化是 改变状态: 转换函数在\(p_i\) 的可访问状态(在配置\(C_{k-1}\)里)上进行操作，清空 \(inbuf_i[l]\)，\((1≤l≤r)\) 发送 msg: 将转换函数制定的消息集合加入 \(C_k\) 里的变量 \(outbuf_i\) 上 调度 ,]]></content>
  </entry>
  <entry>
    <title><![CDATA[Write a Parser in OCaml]]></title>
    <url>%2F2017%2F06%2F25%2Fparser-in-OCaml%2F</url>
    <content type="text"><![CDATA[First we define the language, then translate it into OCaml code. Definition Two part is necessary, 1. Syntax Definition in Bacus-Naur Form to define the “Language”(which is, set of string). 2. And sematics definition to Describe the “Meaning”. Syntax Definition Including lexing and parsing rules. 123&lt;start&gt; ::= &lt;exp&gt; &apos;\n&apos;&lt;exp&gt; ::= &lt;exp&gt; &lt;op&gt; &lt;exp&gt; | [&quot;0&quot;-&quot;9&quot;]+&lt;op&gt; ::= &quot;+&quot; | &quot;-&quot; Sematics Definition This is the AST(Abstract Syntax Tree) definition, sine we want to write a frontend for a compiler. 12type op = Plus | Minus type exp = Exp of exp * op * exp | Num of int Implementation We need to implement four parts part file method lexer lexer.mll ocamllex parser parser.mly ocamlyacc AST ast.ml by hand, some lib for pretty printing driver driver.ml by hand Translate language definition to code In our Bacus-Naur Form definition, those symbols quoted with ' &quot; should be denoted as Lexeme simble. and defined in the parser.mly file. 123&lt;start&gt; ::= &lt;exp&gt; &apos;\n&apos;&lt;exp&gt; ::= &lt;exp&gt; &lt;op&gt; &lt;exp&gt; | [&apos;0&apos;-&apos;9&apos;]+&lt;op&gt; ::= &quot;+&quot; | &quot;-&quot; \(\Downarrow\) 123456789// regular grammar&lt;EOL&gt; ::= &apos;\n&apos;&lt;NUM&gt; ::= [&apos;0&apos;-&apos;9&apos;]+&lt;PLUS&gt; ::= &quot;+&quot;&lt;MINUS&gt; ::= &quot;-&quot;// context free grammar&lt;start&gt; ::= &lt;exp&gt; &lt;EOL&gt;&lt;exp&gt; ::= &lt;exp&gt; &lt;op&gt; &lt;exp&gt; | &lt;NUM&gt;&lt;op&gt; ::= &lt;PLUS&gt; | &lt;MINUS&gt; Regular grammar tokens are defined in the header of parser.mly, like this 1234%token &lt;int&gt; NUM%token PLUS MINUS%token EOL%left PLUS MINUS and produced by lexer.mll, like this 1234567rule token = parse [&apos; &apos; &apos;\t&apos;] &#123; token lexbuf &#125; | &apos;\n&apos; &#123; Parser.EOL&#125; | [&apos;0&apos;-&apos;9&apos;]+ as i &#123; Parser.NUM(int_of_string i) &#125; | &apos;+&apos; &#123; Parser.PLUS &#125; | &apos;-&apos; &#123; Parser.MINUS &#125; | eof &#123; raise Eof &#125; Context free grammar are put in the main part of the parser.mly The AST part can be put in the ast.ml file directly. Some utility function for error handling and pretty printing can be put here.]]></content>
  </entry>
  <entry>
    <title><![CDATA[始まりの物語]]></title>
    <url>%2F2017%2F03%2F01%2F%E5%A7%8B%E3%81%BE%E3%82%8A%E3%81%AE%E7%89%A9%E8%AA%9E%2F</url>
    <content type="text"><![CDATA[博客 引擎 Hexo, markdown 生成静态网页，轻松部署到 Github。 主题 NexT 评论 disqus, 多说评论挂了，Disqus 需要翻墙。 Markdown 功能测试 H3 H4 H5 H6 基本 markup normal ita ita bold underscores, strikethrough jump to google item item li li a * b, a_b , a\b 数学公式 MathJax Ref inline formulas: $a = \sum_{i=1}^{n} x_i$ \(a = \sum_{i=1}^{n} x_i\) displayed formulas: $$ \alpha ::= \tau \times \lambda $$ \[ \alpha ::= \tau \times \lambda \] Warning! 默认 markdown 编译器是 hexo-renderer-marked, 对于\\ * _ 的翻译有 bug, BUG: 混合 _ and $ 1$a_1, a_2$ \(a_1, a_2\) 1$a_0 a_&#123;n-1&#125;$ \(a_0 a_{n-1}\) 换一个renderer，在 hexo 插件页上有几个选择。 hexo-renderer-pandoc, 没问题了。 还有一个 hexo-renderer-markdown-it, 没试. 1$a\_0 a\_&#123;n - 1&#125; $ $a_0 a_{n - 1} $ \(a\_0\) Tables Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码 incline code 12345678(* invariant: *)(* x,y = exgcd(a,b) *)(* ax + by = gcd(a,b) *) let rec exgcd(a,b) : int * int = if a mod b = 0 then 0, 1 else let x,y = exgcd(b, a mod b) in y, x - y * (a/b);;]]></content>
      <tags>
        <tag>self-referencing</tag>
      </tags>
  </entry>
</search>
