<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Logic, Conjunctive Normal Form]]></title>
    <url>%2F2018%2F05%2F14%2FLogic-Conjunctive-Normal-Form%2F</url>
    <content type="text"><![CDATA[Conjunctive normal forms are AND of ORs. \[(A \lor B) \land (A \lor \neg B)\] 另一种写法. \[ (A + B) \times (A + \overline{B})\] A can be true or false, B too. Draw a picture. 定义有限集合 \(A_k = \{x_0, x_1, x_2,\ldots, x_k \}\) 每个元素 \(x_i \in \{T, F\}\), 所以 \(|A_k| = 2^k, A_k \in \{T,F\}^k\) .. 额, 这个好像不是我想要的.. 称 \(\{T,F\}^k = \mathbb{2}^k\) 为 真值空间. \(A_k\) 是这个空间的一个点. 一个 CNF 是真值空间的一个子集. 定义 \(X_0 \subset \mathbb{2}^k\), 一个子空间, where \(x_0 = T\), 定义 \(\overline{X_0} \subset \mathbb{2}^k\), where \(x_0 = F\), \[(A \lor B) \land (A \lor \neg B)\] 就是 \[(X_A \cup X_B) \cap (X_A \cup \overline X_B)\] 这算是 CNF 的语义. 还有语法的定义. 123type literal = string * booltype clause = literal listtype cnf = clause list CNF 的表达能力? CNF, 包含一个字母表 \(A_k\), Boolean satisfiability problem SATisfiability problem. 给定一个 CNF, 在 \(\mathbb{2}^k\) 找一个 点, 它在 CNF 中. 如果有这样一个解(点), 验证很容易, 但是找这个点是 NP-complete 的. A simple general SAT solver (copied from stanford cs242): 1234567891011121314151617let satisfiable (atoms : string list) (cnf : cnf) : assignment option = let rec iter_cnf (assignment : assignment) (cnf : cnf) : assignment option = match cnf with | [] -&gt; Some (List.fold atoms ~init:assignment ~f:(fun assignment atom -&gt; match String.Map.find assignment atom with | None -&gt; String.Map.add assignment ~key:atom ~data:true | Some _ -&gt; assignment)) | clause :: cnf' -&gt; List.fold clause ~init:None ~f:(fun acc (atom, affinity) -&gt; (match (acc, String.Map.find assignment atom) with | (Some _, _) -&gt; acc | (_, None) -&gt; (*none, none*) iter_cnf (String.Map.add assignment ~key:atom ~data:affinity) cnf' | (_, Some affinity') -&gt; if affinity = affinity' then iter_cnf assignment cnf' else None)) in iter_cnf String.Map.empty cnf 不是遍历 \(\mathbb{2}^k\), 而是这么看 CNF: CNF 是 很多个 ORs 的 AND, 要满足这个CNF, 需要满足每一个 ORs. 每一个 ORs 都是很多个 逻辑变量的 OR, 其中只要有一个满足就行了. cnf = clause :: cnf' clause = literal :: clause' add this literal to assignment, recursively call iter_cnf assignment cnf' 如果不行, 就换下一个 literal, 直到 clause’ 为 nil, 说明确实找不到. 这代码正确性怎么证明? cnf 是一个 nested list. 从外层 list 递归可以吗?]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Energy Types]]></title>
    <url>%2F2018%2F05%2F08%2FEnergy-Types%2F</url>
    <content type="text"><![CDATA[ENT language Abstract Syntax symbol 上的横线用来表示 这是个 list, 类似 BNF 里面 asterisk 的作用. (第一次见到这种写法) Terms \[P ::= D \, \overline{C}\] Program is made of mode declarations and classes. This is because ENT is derived from Java. \[D ::= \overline{\mathtt{m} \le \mathtt{m}}\] mode declarations are an order relation on modes. \(mathtt{m}\) is a mode’s name. A mode can used to represent an energy state. high energy mode, middle energy mode, low energy mode. \[C ::= \mathbf{class}\; \mathtt{c}\; \Delta\; \mathbf{extends}\; \mathtt{c} \; \{\overline{F}\; \overline{M} \; A\}\] classes extends other classes. A class’s body consists of field, methods and attributor. \(\mathtt{c}\) is the name of some class. \[F ::= T \; \mathtt{fd} = e\] field is Type and expression, \(\mathtt{fd}\) is the field’s name. These are Java things, but the Type can be tagged with energy modes. \[M ::= T \; \mathtt{md}(\overline{T}\; \overline{x}) \{e\}\] method, \(\mathtt{md}\) is the method’s name. \[A ::= e\] attributor. In ENT, if a class is declared to be dynamic (has type \(?\)), it must be associated with an attributor. An atributor can be arbitrary Java code, allowing the object to inspect the class information at run time, and get the runtime mode of the object. \[\begin{aligned}e ::= &amp; \; x \;|\; e.\mathtt{fd} \;|\; \mathbf{new}\; \mathtt{c}\langle \iota \rangle \;|\; e.\mathtt{md}(\overline{e}) \;|\; (T)e \\| &amp; \; \mathbf{snapshot}\;e\;[\eta,\eta&#39;] \;|\; \mathbf{mcase}\langle T\rangle\{\overline{m:e}\} \;|\; e \rhd \eta\end{aligned}\] expression \(\mathbf{snapshot}\) take the mode of an expression \(e\) and check if it in range \([\eta, \eta&#39;]\). \(\mathbf{mcase}\) 类似函数式编程里的 match 语句, 把 mode 映射到 expression. \(e \rhd \eta\) “the mode case elimination expression”. &gt;In the concrete syntax, mode case elimination for local field access is implicitly represented as \(\mathtt{depth \rhd X}\) ???, 大概是说 class 的 field 的 mode 默认为 enclosing class 的 mode. Types \[T ::= \mathtt{c} \langle\iota\rangle \;|\; \mathbf{mcase}\langle T\rangle\] programmer type, \[\iota ::= \eta \;|\; ?, \eta\] object parameter list. \(?\) is a dynamic type, its real type must(?) be determined by an attributor. \[\eta ::= \mathtt{m} \;|\; \mathtt{md} \;|\; \top \;|\; \bot\] static mode , \(\mathtt{m}\) is mode name , \(\mathtt{md}\) is method name. \[\omega ::= \eta \le \mathtt{mt} \le \eta&#39;\] constrained mode, \(\mathtt{mt}\) is mode type variable. \[\Delta ::= ? \to \omega, \Omega \;|\; \Omega\] class parameter list \[\Omega ::= \overline{\omega}\] constrained mode list Type System Elements \[\mu ::= \eta \;|\; ?\] mode \[\tau ::= T \;|\; \exists \omega .\tau \;|\; \mathtt{modev}\] type. \(\mathtt{modev}\) is for typing attributor. \[\Gamma ::= \overline{\mathtt{x} : \tau}\] typing environment \[\mathtt{K} ::= \overline{\eta \le \eta&#39;}\] constraints. Functions \(\mathtt{mtype}(\mathtt{md}, T)\) return the signature for method \(\mathtt{md}\) of object of type \(T\). This is Java, a method also belongs to some object or class. \(\mathtt{mtype}\) 这符号没必要. This can be expressed like this : \(e : T \land e.\mathtt{md} : T_0\). \(\quad T_0\) is what \(\mathtt{mtype}()\) returns. \[\mathtt{omode}(\mathtt{c}\langle \iota \rangle ) \triangleq \mu \text{ if } \iota = \mu, \overline{\eta}\] \(\mathtt{omode}\) get the mode of an object of type \(\mathtt{c}\langle \iota \rangle\), it simply get the first mode in the mode list. \[\begin{aligned} \mathtt{cmode} &amp; (? \to \omega, \Omega) \triangleq ? \\ \mathtt{cmode} &amp; (\omega, \Omega) \triangleq \omega \end{aligned}\] \(\mathtt{cmode}\) gets the mode from a class parameter list. Return the first constrained mode. Note the difference between a object’s mode and a class’s mode. an object’s mode is a specific value. but a class’s mode is a range. \(\mathtt{mode}(P)\) represents all modes in the Program \(P\). Expression Typing Definition: Judgment \(\Gamma;\mathtt{K} \vdash e : \tau\), says expression \(e\) has type \(\tau\) under typing environment and constraint set \(\mathtt{K}\). Definition: \(\Gamma(\mathtt{x})\) is the \(\mathtt{x}\)’s type in \(\Gamma\). 这个也很没必要, \(\Gamma \vdash \mathtt{x} : T\) 不就能表示了么, 明明用大家熟悉的 relation 能够表达的, 偏要自己定义一个函数. 严格来说, 函数并不是能够随便定义的, 还要 先证明 \(\forall x, y.\; x = y \Rightarrow f(x) = f(y)\). Definition: \(\mathtt{K} \looparrowright \mathtt{K}&#39;\), iff the reflexive and transitive closure of \(\mathtt{K}&#39; \cup D\) is a subset of that of \(\mathtt{K} \cup D\) . What ??? \[ \begin{aligned} &amp;\mathtt{cons}(\overline{\eta \le \mathtt{mt} \le \eta&#39;}) \triangleq \cup \{\eta \le \mathtt{mt}, \mathtt{mt} \le \eta&#39;\} \\ &amp;\mathtt{cons}(? \to \omega, \Omega) \triangleq \{\eta \le \mathtt{mt}, \mathtt{mt} \le \eta&#39;\} \cup \mathtt{cons}(\Omega) \quad\text{ if } \omega = \eta \le \mathtt{mt} \le \eta&#39; \end{aligned} \] cons 操作类似于格上求 join 或 meet. Definition: Static Water fall Invariant \[ \mathtt{sfall}(T, T&#39;, \mathtt{K}) \text{ iff } \mathtt{K} \looparrowright \{\mathtt{omode}(T) \le \mathtt{omode}(T&#39;)\} \] 不理解 \(\looparrowright\) 就没法继续了. Typing Rules \[(\text{T-New}) \frac{\iota = ?,\iota&#39; \text{ iff }\mathbf{class}\ \mathtt{c}\ \Delta \cdots \in P \text{ and } \mathtt{cmode}(\Delta) = ? \qquad \mathtt{K} \looparrowright \mathtt{cons}(\Delta)} {\Gamma;\mathtt{K} \vdash \mathbf{new}\;\mathtt{c} \langle \iota \rangle : \mathtt{c} \langle \iota \rangle}\] \(P\) ?, \(P\) is implicit. We could write \[{\Gamma;\mathtt{K};P \vdash \mathbf{new}\;\mathtt{c} \langle \iota \rangle : \mathtt{c} \langle \iota \rangle}\] So, how to interpreter this ? Why is there an \(\text{iff}\) in the predicate? Did the author put it in the wrong place? Maybe it says two things, a definition and a rule. Not a definition. There’s nothing new. 使用 \(\text{iff}\) 时, 如果一个左边引入新的符号, 则是一个定义; 如果没有新的符号, 看成一个逻辑连接符就行了. \(\text{iff}\) means, two judgements must both be true of false at the same time. \(\iota = ?,\iota&#39;\) means that the first mode in the class’s parameter list is \(?\). This is a static type and is specified in this new statement. \(\mathbf{class}\;\mathtt{c}\;\Delta \cdots \in P \text{ and } \mathtt{cmode}(\Delta) = ?\) means that the first mode in the class’s definition’s parameter list is \(?\). This is a constraint type and is specified in the definition of the class. This rule 说明 \(\mathbf{new}\;\mathtt{c}\langle\iota\rangle : \mathtt{c}\langle\iota\rangle\) 也是有条件的. \(\looparrowright\) ??? \[(\text{T-Msg})\frac {\Gamma;\mathtt{K} \vdash e : T_0 \qquad \mathtt{mtype}(\mathtt{md}, T_0) = \overline{T} \to T \qquad \Gamma;\mathtt{K} \vdash \overline{e} : \overline{T} \qquad \mathtt{sfall}(T_0, \Gamma(\mathbf{this}), \mathtt{K}) } {\Gamma;\mathtt{K} \vdash e.\mathtt{md}(\overline{e}) : T} \] 函数调用. \[ (\text{T-Snapshot}) \frac {\Gamma;\mathtt{K} \vdash e : \mathtt{c}\langle?, \iota\rangle \qquad \omega = \eta_1 \le \eta_2 } {\Gamma;\mathtt{K}\vdash \mathbf{snapshot}\;e\;[\eta_1,\eta_2] : \exists\omega.\mathtt{c}\langle\mathtt{mt},\iota\rangle} \] Snapshot 最大疑点, 用 existential type 表示 dynamic type. 我从来就没见过 动态语言的 类型系统.. \[ (\text{T-MCase}) \frac {\overline{\mathtt{m}} = \mathtt{modes}(P) \qquad \Gamma;\mathtt{K} \vdash e_i : T \text{ for all } i } {\Gamma;\mathtt{K} \vdash \mathbf{mcase}\langle T \rangle \{\overline {\mathtt{m} : e}\} : \mathbf{mcase} \langle T \rangle } \] mcase \[ (\text{T-ElimCase}) \frac {\Gamma;\mathtt{K} \vdash e:\mathbf{mcase}\langle T\rangle\qquad \eta \in \mathtt{modes}(P) \text{ or }\eta \text{ appears in } \mathtt{K} } {\Gamma;\mathtt{K} \vdash e \rhd \eta : T} \] Reference [1] [2] [3] 都是一个组做的工作. [1] has phase and mode, while [3] only has mode. 虽然说 [3] 是基于 [1] 但是还是有很多不同的. [1] Energy Types – OOPSLA’12 [2] Understanding Energy Behaviors of Concurrent Programs – OOPSLA’14 and a short video (1min) [3] Proactive and Adaptive Energy-Aware Programming with Mixed Typechecking – PLDI’17]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mininet Simulation]]></title>
    <url>%2F2018%2F05%2F05%2FMininet-Simulation%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Termbox, an API for text-based UI]]></title>
    <url>%2F2018%2F04%2F23%2FTermbox-an-API-for-text-based-UI%2F</url>
    <content type="text"><![CDATA[Termbox 之前就在 haskell 库里面看到过, 现在又在 lua 里面看到了. 似乎各个语言中都有这个库. 字符界面的 API 感觉挺酷的, 而且在实现简单程序 demo 时也可以考虑使用字符界面而不是GUI. 看一看这个 API 是怎么设计的吧. Viewing terminals as a table of fixed-size cells and input being a stream of structured messages. 把终端看成一个长方形数组, 要求等宽字体 (CJK 会有点问题). 先别看 termbox 是怎么设计的. 想想自己会怎么设计? 1234global window &#123; width, height &#125;clear()draw()set(x, y, char) 最基本的操作就这些了. 再看 termbox 的设计. termfx | lua termbox | go 啊, UI 的API 除了画画, 最重要的的还有 Event 这个东西, 就这么简单. 画画的功能上, 还能增加 “子窗口” 功能.. 啊, 无聊. ps 看到一个 用 termfx 的小编辑器 mle, 挺感兴趣的, 有时间可以看一下. 编辑器算是最常用的软件了, 当然会好奇里面如何设计.]]></content>
  </entry>
  <entry>
    <title><![CDATA[记全国大学生 IoT 创新大赛]]></title>
    <url>%2F2018%2F04%2F22%2F%E8%AE%B0%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F-IoT-%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[参加 IoT 创新竞赛. 汇报了我们的作品 PiCam , 一个基于树莓派的跟踪摄像头. 星期五下午赶往无锡. 华东分赛区. 总共 28 支队, 拿了三等奖. emmmm. 上台后出了些问题, 虽然上台前计划好了每一张 ppt 用时, 手机打开计时器放在面前, 然后就紧张得 一次都没有看计时器. 不知道 win 下的 ppt 视频如何播放. 耽误了一些时间. 还有开始计时似乎不是从我开口开始计的, 放完视频就到 7 分钟了. 评委老师的问题, 无非就是市场调研的疑问. 因为作品讲得很清楚了. 我只是说文档里有些调研. 一般的这样的跟踪摄像头都是上千上万的价格. 其实我觉得 PiCam 的问题就是没有什么难度 和其他的报告相比, 我觉得我们的报告风格和其他作品有点差距. 对于市场的调查, 应用前 景明显不足. 大赛的报告主要关注在与应用. 但是技术上的创新不多, 其中比较 “高科技” 的, 给我印象比较深的: 柔性汗液传感器. 能够贴在皮肤上, 检测汗液成分的 扫描 RFID 定位书架上的书本. 根据 RFID 反射的相位变化. 拟合分析, 定位RFID 位置, 精度厘米级. IOT 弱身份 ID 认证. 问题明确, 但是没说清方法. 防语音识别重放攻击. 用麦克风阵列, 区分真人发音与扩音器发音. 原理是人口发音是从多个部位发声. 电击脑部治疗中风, 将现有设备小型化, 通过了相关医学认证. 其他一般都是在于各种不同的应用场景, 比如 老人监护, 轮椅, 导盲帽子, 水质检查浮标, 水管查漏, 桥梁形变检查, 军用无人车, 船员定位, 宠物喂食, 垃圾桶, 书柜, 储物柜. 跟踪滑板车, RFID 检查箱子倒置. 车辆警告. 坐垫. 感觉和小学时的创意大赛没多大区别, 只是大家不仅仅只会使用纸板胶水, 还会编程了. 图书馆扫描书本的机器人图客居然已经是4代产品了, 从 2012 年开始的项目, 有质量非常高的宣传片. 报告人只是最近加入, 对其中的技术细节也不了解. 其中有些报告人着装上就与众不同, 一身黑色西服的. 一般都是已经创业的. 会提到得到了多少 融资, 已经或者准备量产, 已经在哪里部署了. 已经获得多少专利, 奖项. 比如智能轮椅的. 将手机装在轮椅上. 加上脑电控制, 手机控制, 倒车, 导航等.. 据说已 经有量产了. 像图客, 水质监测, 桥梁形变检测, 水管差漏等, 已经在实验室之外部署了. 军用无人车的四个人一身军装, (路上听到有人来参加物联网峰会的老师说, 那穿军装的是不是中科大的.. 是不是中科大有什么误解…) 做了一个行走方式很特殊的无人车. 创新点在于轮子的设计. 集成了各种传感器, 还搭载了无人机, 携带TNT能自爆, 可惜没能现场演示自爆(笑. 有些报告似乎是面向投资人的. 大量的市场调查. 市场规模, 预期盈利都有了. 也看到了很多质量很糟糕的报告, 满屏幕的字.. 听完之后, 感觉仅从工作量上, 我们的作品就很明显比不了别人了, 除了少数.. 比如那个 贴两个 RFID 到箱子上, 检测箱子是否倒置的. 可跟踪摄像头的设计和实现从4月才开始. 而其他的作品可能已经是实验室几年的项目了. 我觉得自己对做出一个产品并没有什么兴 趣, 除非是自己感兴趣的音乐, 画画相关, 或者是要去创业了, 干嘛要把那么多功能放到 作品里, 比如集成了购物, 视频, 电台功能的轮椅… 我真不知道当时的 PiCam 是怎么通过预选的, 据说大赛有上万个作品. 而当时 picam 只是 一个几十行 python 的东西. 可能是因为对 lifelog 这个应用的市场调研做得不错, 而那 正是评委想要看到的. 另外我还想吐槽: 对参赛作品没有限制的吗? 不是说好每个队伍最多三四个人的吗? 那种实验室 几年的产品怎么也可以!? 就当锻炼一下作报告吧..]]></content>
  </entry>
  <entry>
    <title><![CDATA[Object Tracking on RPi]]></title>
    <url>%2F2018%2F04%2F01%2Fobject-tracking-on-rpi%2F</url>
    <content type="text"><![CDATA[Install SiamFC-TensorFlow on RPi 在笔记本上和 RPi 上都进行测试. 目录: chip:/workspace/object-tracking/siamfc/siamfc-tf pi3:/workspace/ 按官方指南, 使用 virtual-env, 创建一个独立的环境, 不依赖于系统里已经安装的 python 库. siamfc-tf 需要 tensorflow-gpu==1.1.0, tensorflow-gpu 依赖 libcublas, 会在运行时加载 libcublas 动态库, 这个库需要 CUDA. 需要把 tensorflow-gpu 换成 tensorflow, 但是直接使用 pip 安装 tensorflow 失败, 找不到 tensorflow 这个包. 于是使用 tensorflow-on-raspberry-pi 提供的二进制安装. tensorflow-1.1.0 使用 pip 安装依赖 matplotlib 时, 编译错误: 123src/_png.cpp: In member function &apos;Py::Object _png_module::write_png(const Py::Tuple&amp;)&apos;:src/_png.cpp:147:51: error: &apos;npy_PyFile_Dup&apos; was not declared in this scope... change numpy version from 1.11.1 to 1.6.2 NO. I install it manually, OK, 可以运行. 原输入是一个文件夹, 里面都是图, 以及一个框. 输出, 每帧一个框, 图片可以显示. 改成. 输入是摄像头, (初始框暂时不管 region_to_bbox, region is either 4 dim or 8 dim. 4 dim is rect, x y w h, 8 dim is poly, … not sure yet. anyway , only 4 is used here Where did it open the image file? tracker.py 70, it use a for loop to process each frame. sess.run use a feed_dict, which requires a filename for a frame. I need to stop it sess is a tf.Session. what do you what ? see official doc ! It seems that the tf graph is in the global environment. sess.run(), run it. run : Runs operations and evaluates tensors in fetches. feed_dict argument allows the caller to override the value of tensors in the graph. See run() for more information. so the computation has already been defined in the graph definition part. it used a tf.train.Coordinator() to load image file!!! A coordinator for threads. This class implements a simple mechanism to coordinate the termination of a set of threads. 修改 graph, 发现不知道 tensorflow 如何输入图片. 计算图怎么写? 看了下 Session 和 run, 使用 feed_dic 输入 graph. 弄个 place_holder 接受就行了. 这个真的.. 我真的没把这里当成博客啊.. 这不是把屎拉在路上么..]]></content>
  </entry>
  <entry>
    <title><![CDATA[Web Server using NodeJS]]></title>
    <url>%2F2018%2F03%2F26%2FWeb-Server-using-NodeJS%2F</url>
    <content type="text"><![CDATA[Write a http web server, run it on RPi. folder pi3:/workspace/webserver]]></content>
  </entry>
  <entry>
    <title><![CDATA[Inference on Embeded Systems]]></title>
    <url>%2F2018%2F03%2F14%2FInference-on-Embeded-Systems%2F</url>
    <content type="text"><![CDATA[Sparsification and Separation. key Contributions: * A sparse coding-based approach to optimize depp learning inference execution. * Convolution kernel separation technique * The first to do Deep Learning Model on severely constrained wearable hardware. * implement a prototype, * experiment with for CNN and DNN models, 11.3x improvements in memory and 13.3x inexecution time. accuracy loss 5% background: DNN, CNN(DNN with some convolutional layers) local computation: privacy, independent of network condition. Design Goals: * No re-training * No Cloud Offloading * Low-resource platforms. only a few MBs of RAM. * Minimize Model Changes Three technique: * Layer Compression Compiler, for Fully-connected layers * Sparse Inference Runtime, load active layers only * Convolution Separation Runtime, for Convolutional layers. Fully-connected layers: \(f(\mathbf{b} + \mathbf{W} \cdot \mathbf{x})\) Convolutional Layers: \(f(\sum\mathbf{x} \ast \mathcal{K} + \mathbf{b} )\) Weight Factorization: \(W \cdot x\) , \(W\) is m x n, if we factorize \(M = U \cdot V\), \(U\) and \(V\) is m x k, then compressed. Previous work use SVD. This paper improved this by using Dictionary Learning. factorized \(M = B \cdot A\), \(A\) is a sparse matrix. Convolutional Layers: d x d convolutional kernels factorized to d x k and k x d, use SVD. choose k for specified accuracy, memory, and computation time: for each layer, use binary search to find one. evaluation: …]]></content>
      <tags>
        <tag>paper-reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[File Server on Ubuntu]]></title>
    <url>%2F2018%2F03%2F14%2FFile-Server-on-Ubuntu%2F</url>
    <content type="text"><![CDATA[Install samba. configure it. Use Samba on the LAN, FTP over the Internet. File Server | Ubuntu documentation 其实把东西记在博客里一点也不方便. 后来某天想要在树莓派上设置Samba时, 还以为是记在 Note 里面的. 找不到这篇笔记, 才 想起是放在了这里.. 1sudo apt install samba /etc/samba/smb.conf then make some change in the [homes] section. 1234567[homes] comment = Home Directories browseable = yes read only = no create mask = 0775 directory mask = 0775 valid users = %S then sudo service smdb restart &amp;&amp; service nmbd restart failed… Use this. sudo systemctl restart smbd.service nmbd.service This works fine on Ubt17, but failed on my RPi(8 jessie, Raspbian), use this sudo /etc/init.d/samba restart on RPi add user to sambda smbpasswd -a &lt;user-name&gt; Connect to SMB on macOS Finder &gt; Go &gt; Connect to Server… enter an URL 1smb://&lt;ip&gt;/&lt;folder&gt; Enter your user-name (on the file server) and the passwd you’ve just set. Now You can edit files on the server just like editing your local files! 然后安装个 transmission, 把服务器作为 BT 下载器, 也是美滋滋~]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Network Simulator: ns-3]]></title>
    <url>%2F2018%2F03%2F14%2FNetwork-Simulator-ns-3%2F</url>
    <content type="text"><![CDATA[ns-3 is a Network simulator, working directory: nico:workspace/ns3 preparation Normally you need to download the source and build it. Compile failed on MacOS, So I have to use Ubuntu. Download ns-allinone-3.27.tar.bz2. Then tar xf it, and build it: 1./build.py --enable-examples --enable-tests or ./waf -d optimized --enable-examples --enable-tests configure run example ./waf --run hello-simulator in example/tutorial Concepts four basic Concepts: Node: a machine, pc, router, switch Application: program Channel: between nodes csma, p2p, wifi NetDevice: Network interface Card and driver. Topology Helper: attach NetDevice to Node and Channel, do configuration NodeContainer create, access and manage Node objects Using ns-3 First read example/tutorial/first.cc ( by the first line -*- Mode:C++ I can see that the author uses Emacs! ) Include headers 12345#include "ns/core-module.h"#include "ns/network-module.h"#include "ns/internet-module.h"#include "ns/point-to-point-module.h"#include "ns/applications-module.h" A lot of modules… log component NS_LOG_COMPONET_DEFINE (&quot;FirstScriptExample&quot;); This is defined in log.h. 1static ns3::LogCompoinent g_log = ns3::LogComponent(name, __FILE__) logs need to be enabled. 1LogComponentEnable("FirstScriptExample", LOG_LEVEL_INFO) Use NS_LOG_INFO (&quot;what you want to say&quot;) to print staff at info level Copmile and run the script 123456789101112cp examples/tutorial/first.cc scratch/myfirst.cc./waf # compile./waf --run scratch/myfirst``But No output ..So I rebuild ... something``` shell./waf configure -d debug./waf Now I can see the log output. 1234At time 2s client sent 1024 bytes to 10.1.1.2 port 9At time 2.00369s server received 1024 bytes from 10.1.1.1 port 49153At time 2.00369s server sent 1024 bytes to 10.1.1.1 port 49153At time 2.00737s client received 1024 bytes from 10.1.1.2 port 9 Command Line parser 1234./waf --run "scratch/myfirst --PrintHelp"./waf --run "scratch/myfirst --PrintAttributes=ns3::PointToPointNetDevice"./waf --run "scratch/myfirst --ns3::PointToPointNetDevice:DataRate=5Mbps --ns3::PointToPointChannel::Delay=2ms" 123456uint32_t nPackets = 1;CommandLine cmd;cmd.AddValue("nPackets", "Number of packets to echo", nPackets);cmd.Parse (argc, argv);// ...echoClient.SetAttribute ("MaxPackets", UintegerValue (nPackets)); ASCII tracing 12AsciiTraceHelper ascii;pointToPoint.EnableAsciiAll (ascii.CreateFileStream ("myfirst.tr")); Each line represents a trace event, four types of events +: an enqueue event happens on the device -: a dequeue event happens on the device d: a packet is dropped on the device r: the device receives a packet PCAP tracing Enable PCAP(packet capture) tracing: 1pointToPoint.EnablePcapAll ("myfirst"); output to myfirst-0-0.pcap and myfirst-1-0.pcap. numbers indicate node and device. use tcpdump to show the trace 1tcpdump -nn -tt -r myfirst-0-0.pcap API use summary To implement an ns-3 application. create nodes setup channel, installed on nodes install protocol stack on nodes allocate addresses for nodes install program on nodes start - stop c++ is quite verbose. but it’s ok once you get used to it. wifi 还有更细节的物理层的 设置, 比如 node 的位置和随时间的移动. 但是我还是觉得这种 API 设计挺糟糕的. 本来这些 API 都只是些设置的东西. 却要分成 这么多行代码. 新手需要记住需要哪些步骤, 需要以怎样的步骤来调用. 就算实际上各个参数 都有默认参数, 或者是顺序无影响, 也会给用户带来额外负担. 比如说 csmaHelper, 我能不能重复使用呢, 即按照一次后它自身的状态会变化吗? 另外 Helper 类的属性也不好用, 作者说是为了灵活性.. 将有副作用和无副作用的 API 分开. 初始化模型用参数表来提示用户需要哪些前提参数, 多好. 属性就直接作为一个域放在类里, 不然编辑器IDE根本帮不上忙, 你完全不知道有哪些属性可以用. WifiNetDevice 如果只能和 WifiChannel 在一起工作的话, 请用 Type System 约束一下, 或者不要让用户有这个能力把 WifiNetDevice 连上 CsmaChannel. Topology 功能也感觉好复杂. 好的API的设计应该让我不用看文档就能直接仿照例子写自己的程序了. 用 json 或 xml 描述一下网络就能跑是最好了.. node, device, interface 都分散在各个变量中. 如果之后有时间, 大概 会创建一个类来保存这些信息. (为什么库不提供啊!) 心累.. 还有好几个实验呢..]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ML-oxford]]></title>
    <url>%2F2018%2F01%2F12%2FML-oxford%2F</url>
    <content type="text"><![CDATA[linear \(\hat{y} = \mathrm{X} \theta\) \(X = \begin{bmatrix} x_{11}\end{bmatrix}\) \(J(\theta) = (y - X\theta)^T (y - X\theta) = \sum_{i=1}^{n}(y_i - x_i^T\theta)^2\) matrix differentiation.]]></content>
  </entry>
  <entry>
    <title><![CDATA[pathfinding]]></title>
    <url>%2F2018%2F01%2F09%2Fpathfinding%2F</url>
    <content type="text"><![CDATA[from wiki A pathfinding method searches a graph by starting at one vertex and exploring adjacent nodes until the destination node is reached. Two primary problems of pathfinding are (1) to find a path between two nodes in a graph; and (2) the shortest path problem—to find the optimal shortest path. Basic algorithms such as breadth-first and depth-first search address the first problem by exhausting all possibilities; starting from the given node, they iterate over all potential paths until they reach the destination node. These algorithms run in \(O(|V|+|E|)\), or linear time, where V is the number of vertices, and E is the number of edges between vertices. The more complicated problem is finding the optimal path. The exhaustive approach in this case is known as the Bellman–Ford algorithm, which yields a time complexity of \(O(|V||E|)\), or quadratic time. However, it is not necessary to examine all possible paths to find the optimal one. Algorithms such as A*and Dijkstra’s algorithm strategically eliminate paths, either through heuristics or through dynamic programming. By eliminating impossible paths, these algorithms can achieve time complexities as low as \(O(|E|\log⁡(|V|))\). The above algorithms are among the best general algorithms which operate on a graph without preprocessing. However, in practical travel-routing systems, even better time complexities can be attained by algorithms which can pre-process the graph to attain better performance. One such algorithm is contraction hierarchies. Bellman-Ford algorithm Dijkstra’s algorithm begins with a start node and an “open set” of candidate nodes. At each step, the node in the open set with the lowest distance from the start is examined. The node is marked “closed”, and all nodes adjacent to it are added to the open set if they have not already been examined. This process repeats until a path to the destination has been found. 算法会找到从起始顶点到每个顶点(距离小于起始顶点到目标顶点最短路径)的最短路径. Dijkstra’s algorithm fails if there is a negative edge weight. A* algorithm Sample algorithm 1234567891011121314151617181920212223 1 2 3 4 5 6 7 8X X X X X X X X X XX _ _ _ X X _ X _ X 1X _ X _ _ X _ _ _ X 2X S X X _ _ _ X _ X 3X _ X _ _ X _ _ _ X 4X _ _ _ X X _ X _ X 5X _ X _ _ X _ X _ X 6X _ X X _ _ _ X _ X 7X _ _ O _ X _ _ _ X 8X X X X X X X X X X 1 2 3 4 5 6 7 8X X X X X X X X X XX _ _ _ X X _ X _ X 1X _ X _ _ X _ _ _ X 2X S X X _ _ _ X _ X 3X 6 X 6 _ X _ _ _ X 4X 5 6 5 X X 6 X _ X 5X 4 X 4 3 X 5 X _ X 6X 3 X X 2 3 4 X _ X 7X 2 1 0 1 X 5 6 _ X 8X X X X X X X X X X]]></content>
  </entry>
  <entry>
    <title><![CDATA[distributed algorithm]]></title>
    <url>%2F2018%2F01%2F08%2Fdistributed-algorithm%2F</url>
    <content type="text"><![CDATA[分布式算法 模型： 异步共享存储 异步msg传递 同步msg传递 拓扑：无向图，节点为处理机，边喂双向信道. 算法：由每个处理器上的局部程序构成，包括本地计算和收发msg 节点 \(p_i\), \(p_i\) 相邻的边 \(r\) 条. \(p_i\) 有两个 buffer list: \(outbuf_i[l]\) , \(inbuf_i[l]\), \(l \in [1, r]\) 配置：某时刻，算法运行的全局状态。为一个向量 \((q_0, \ldots, q_{n-1})\), \(q_i\) 是 \(p_i\) 的状态. 状态 事件：两种 \(comp(i)\), 计算事件. \(del(i,j,m)\), 传递事件，将msg \(m\) 从 \(p_i\) 传递到 \(p_j\). 转换函数 执行: 配置和事件交错的序列。 Safety 条件。 (用来证明算法正确性吗?) 该条件在每个有限前缀里的都成立 Liveness 条件。 必须成立一定次数。 满足所有安全性条件的序列称为一个执行, 满足所有活跃性条件的 执行 为 容许(admissible) 的执行。 下面主要考虑异步msg传递系统。 执行片段 \(\alpha\) 是一个有限或无限的序列: \[ C_0, \Phi_1, C_1, \Phi_2, C_2, \ldots, \] 其中 \(C_k\) 是一个配置, \(\Phi_k\) 是一个事件. 如果 \(\alpha\) 有限, 则它必须结束于某个配置, 且需满足下述条件: 若 \(\Phi_k = del(i,j,m)\), 则 \(m\) 必须是 \(C_{k-1}\) 时 \(outbuf_i[l]\) 的元素. \(l\) 是 \(p_i\) 信道 \({p_i, p_j}\) 的标号. 从 \(C_{k-1}\) 到 \(C_k\) 的唯一变化是将 \(m\) 从 \(C_{k-1}\) 里的 \(outbuf_i[l]\) 中 删去, 加入到 \(C_k\) 的 \(inbuf_i[h]\), \(h\) 是 \(p_j\) 的信道 \({p_j, p_i}\) 的标号. 若 \(\Phi_k = comp(i)\), 则 \(C_{k-1}\) 到 \(C_k\) 的变化是 改变状态: 转换函数在\(p_i\) 的可访问状态(在配置\(C_{k-1}\)里)上进行操作，清空 \(inbuf_i[l]\)，\((1≤l≤r)\) 发送 msg: 将转换函数制定的消息集合加入 \(C_k\) 里的变量 \(outbuf_i\) 上 调度 , 调度(或调度片段)总是和执行(或执行片段)联系在一起, 它是执行中的时间序列: \[ \Phi_1, \Phi_2, \ldots\] 并不是每个事件序列都是调度. 例如, \(del(1,2,m)\) 不是调度, 因为在此时间之前, \(p_1\) 没有 send m. 若局部程序是确定的, 则执行(或执行片段)由 初始配置 \(C_0\) 和调度(或调度片段) \(\sigma\) 唯一确定, 可表示为 \(exec(C_0, \sigma)\) 容许执行: 满足活跃性条件的执行. 容许调度: 容许执行的调度. 同步系统, 同步模型中, 执行分为轮, 每轮里, (1)每个处理器能够发送一个 msg 到每个邻居 (2) 每个处理器一接到 msg 就进行计算. 轮 同步系统中, 每轮由一个传递时间(outbuf发送, 清空), 紧跟一个计算时间 (处理所有msg) 终止, 所有处理机均处于终止状态且没有msg 在传输. msg复杂度 实际很少用状态转换来描述算法, 往往用伪码描述. 生成树]]></content>
  </entry>
  <entry>
    <title><![CDATA[approximate algorithm]]></title>
    <url>%2F2018%2F01%2F08%2Fapproximate-algorithm%2F</url>
    <content type="text"><![CDATA[近似算法 总结 [TOC] NP-completeness 可计算 计算模型 Church-Turing Halt(Program, input) 确定型图灵机 非确定型图灵机sa P类问题: 一类问题的集合, 对其中的任一问题, 都存在 一个确定型图灵机 \(M\) 和一个多项式 \(p\), 对于该问题的任何(编码)长度为\(n\) 的实例, \(M\) 都能在 \(p(n)\) 步内, 给出回答. 即多项时间内可解的问题 NP类问题: 一类问题的集合, 对其中的任一问题, 都存在一个非确定型图灵机 \(M\) 和 一个多项式\(p\), 对该问题的任何(编码)长度为 \(n\) 的实例, \(M\) 都能在 \(p(n)\) 步内, 给出对该实例的回答. 若 NTM]]></content>
  </entry>
  <entry>
    <title><![CDATA[paralell computing]]></title>
    <url>%2F2018%2F01%2F05%2Fparalell-computing%2F</url>
    <content type="text"><![CDATA[paralell data dependency statement S, T, define \(S \,\delta\, T\): \(T\) depends on \(S\), \(S\) must be executed before \(T\) \(S\,\delta\,T\) if and only if one of the cases are true. \(x\) is a variable flow dependency: \(S\,\delta^f\,T\), if \(x \in OUT(S)\), and \(x \in IN(T)\). and \(x\) is readed in \(T\) S: x = a + b T: y = x Read after wrtie. reverse dependency: \(S\,\delta^a\,T\), if \(x \in IN(S)\) and \(x \in OUT(T)\). and \(S\) read \(x\) before \(T\) write to \(x\) S: r = x T: x = a + b Write after read. output dependency: \(S\,\delta^o\,T\), if \(x \in OUT(S)\) and \(x \in OUT(T)\). \(S\) write to \(x\) before \(T\) write to \(x\). S: x = a T: x = b Write after write.]]></content>
  </entry>
  <entry>
    <title><![CDATA[eigen]]></title>
    <url>%2F2017%2F12%2F30%2Feigen%2F</url>
    <content type="text"><![CDATA[计算矩阵的全部特征值的 QR 方法 QR 分解指, 将矩阵 \(A\) 分解为 \(A = QR\), \(R\) 是上三角矩阵, \(Q\)是正交矩阵. 利用QR分解求矩阵特征值的方法如下: \(A_1 = Q_1 R_1\) \(A_2 = Q_1^{-1} A_1 Q_1 = Q_1^{-1}Q_1 R_1 Q_1 = R_1 Q_1\) 即分解后交换 QR 再相乘, 反复迭代这回收敛到以A 的特征值为对角线元素的上三角矩阵. 并行算法就是将 QR 分解和矩阵相乘的两个步骤并行化. 离散小波变换 DWT]]></content>
  </entry>
  <entry>
    <title><![CDATA[string match]]></title>
    <url>%2F2017%2F12%2F13%2Fstring-match%2F</url>
    <content type="text"><![CDATA[问题, Pattern, \(P : \Sigma^m\), Text \(T : \Sigma^n\) \(n \ge m\), 找 P 在 T 中的位置. Hash 函数 \(hash\) , 求 \(hash(P)\), 与 \(T\) 的所有长度 \(m\) 的子串. 先比较 Hash, 如果 hash 值相等, 再精确比较. 要求是 hash 计算得快, 最好是 \(hash(T[i, i+m-1])\) 可以从 \(hash(T[i-1, i+m-2])\) 在 \(O(1)\) 的时间内算出来. 一种是 Rabin-Karp 的, hash 是多项式, \(p\) 是一个素数. \(hash([a_1, a_2, \ldots, a_m]) = a_1 + a_2 \cdot p + a_3 \cdot p^2 + \ldots + a_m \cdot p^{m-1}\) 并行课本上的算法如下. 假设 \(\Sigma = \{0, 1\}\), \[ f(0) = \begin{bmatrix} 1 &amp; 0 \\ 1 &amp; 1 \end{bmatrix}, f(1) = \begin{bmatrix} 1 &amp; 1 \\ 0 &amp; 1 \end{bmatrix}\] 取一个小于 \(M\) 的素数\(p\), \(\mathbb{Z}_p\) 是整数环. \(f_p(X) = f(X) \mod p\), 求 \(f_p(T[i, i+m-1])\) ? 说实话, 书上根本没写清楚怎么算. 猜测应该是矩阵相乘. \(f([a_1, a_2, \ldots, a_m]) = f(a_1) \times f(a_2) \times \ldots \times f(a_m)\) 试一下 123456789101112import numpy as npfrom functools import reducef = [np.empty((2,2), dtype=np.int64)] * 2f[0] = np.array([(1,0), (1,1)])f[1] = np.array([(1,1), (0,1)])def hash(t): return reduce(lambda x,y: x.dot(y), map(lambda x: f[x], t))print(hash([0,1,0,1]))print(hash([1,1,0,1])) 1234[[2 3] [3 5]][[3 5] [1 2]] 而且我们知道 \(f(0)^{-1} = \begin{bmatrix} 1&amp; 0\\ -1&amp; 1\end{bmatrix}\) \(f(1)^{-1} = \begin{bmatrix} 1&amp; -1\\0&amp;1\end{bmatrix}\) 串行执行的话, 使用这个hash, 算法复杂度是 \(O\)(Text的长度) , 我没有看出来上面的 \(f_p\) 模 \(p\) 的必要性. 暂且认为 \(\mod p\) 的目的是防止结果溢出. 课本接下来说, 为了并行处理. 希望 hash算法也并行化. 这要求 hash 函数(对于字符串 连接操作)满足同态, 即 \(hash([T, S]) = hash(X)\cdot hash(Y)\) 显然上面的 \(hash\) 是满足的要求的, 看书上又给出了什么吧: 定义 \[g_p(0) = f_p(0)^{-1} \begin{bmatrix} 1&amp; 0\\ p-1&amp; 1\end{bmatrix}, g_p(1) = f_p(1)^{-1} \begin{bmatrix} 1&amp; p-1\\ 0&amp; 1\end{bmatrix}\] 因为 \(\mathbb{Z}_p\) 中\(p = -1\), 其实上面定义的\(g_p\) 就是 \[g_p(0) = f_p(0)^{-1} \cdot f_p(0)^{-1}, g_p(1) = f_p(1)^{-1} \cdot f_p(1)^{-1}\] \(N_i = f_p(T[1,i])\) \(R_i = g_p(T[i]) g_p(T[i-1])\ldots g_p(T(1))\) 容易看到 \(f_p(T[i, i+m-1]) = R_{i-1} N_{i+m-1}\) 得出的结论就是..课本少写了一个等号(无语), 实际上\(g_p(\cdot) = f_p(\cdot)^{-1}\) 并行算法就是先计算出所有的 \(R_i\) and \(N_i\), 这两个都类似前缀和, 可以并行计算.]]></content>
  </entry>
  <entry>
    <title><![CDATA[组合数学课]]></title>
    <url>%2F2017%2F12%2F12%2Fcombinatorics%2F</url>
    <content type="text"><![CDATA[先是在wiki上找了一下组合数学的词条. 发现涵盖的东西居然这么多. 有机会再看. 这篇只是用来总结课堂的一些知识. 鸽巢原理 定理: 把 n+1 个物体放在 n 个盒子里, 至少有一个盒子里有两个以上的物体. 定理: 鸽巢定理推广. \(q_1, q_2, \ldots, q_n \in \mathbb{Z^+}\) , 把 \(\sum_i q_i - n + 1\) 个物体放入 \(n\) 个盒子, 第一个盒子至少 \(q_1\) 个物体, 或者第二个盒子中至少有 \(q_2\) 个物体, … , 或者第 n 个盒子中至少有 \(q_n\) 个物体. 这两个定理用反证法很容易证明. 课本前半部分都是一些很古典的组合数学问题. 用物体, 盒子等定义不明的语言描述. 这里试着用集合论语言描述一下. 物体集合 O (object), 可数集合 盒子/标签 集合 T (type), 可数集合. 一个方案/安排 a (arrangement), 是一个映射 \(a \in O \to C\), \(O \to C\) 表示所有值域为 \(O\), 定义域为 \(C\) 的映射的集合. 所有方案\(A = O \to C\), 许多问题问的就是 \(|A|\). 鸽巢定理: \(|O| = n+1\), \(|T| = n\), 记 \(A = O \to T\) \(\forall a \in A\) , \(\exists t_0 \in T\), \(|a^{-1}(t_0)| &gt; 1\) 这里用映射的逆表示从值域映射到定义域集合的一个映射. 不得不说, 这么写的话, 定理的含义模糊了很多. 定理的成立也不那么明显了. Ramsey 数 略 排列与组合 加法乘法原则 加法原则: 事件 A 有 m 种选取方式, 事件 B 有 n 种选取方式, 则选择 A 或 B, 有 m + n 中选取方式. 这有什么意义? 太显然了.. 一个事件A 有 m 种选取方式是什么意思? 这里并不涉及上面提到的 Object 和 Type. (因为一时想不到答案.. 走神看QQ去了..). 加法原则可以看做是单纯的集合相加. 看下面的乘法原则吧. 乘法原则: 事件 A 有 m 种选取方式, 事件 B 有 n 种选取方式, 选取 A 然后选取 B 有 mn 中选取方式 这不也仅仅是集合相乘吗.. 减法原则, 除法原则 集合的排列 n 元集合 S 的一个 r 排列是指从 S 中选 r 个元素, 依次排列. 方案数记为 \(P(n,r)\) \[P(n, r) = \frac{n!}{(n-r)!}\] 集合组合 n 元集合 S 的 r 组合是指从 S 中选取 r 个元素的无序选择. 方案数记为 \(\binom{n}{r}\). or \(C_n^r\) \[\binom{n}{r} = \frac{n!}{r!(n-r)!}\] 这个是 S 集合的大小为 r 的子集的个数 多重集合的排列 多重集合里面可能会有相同元素, 比如 \(M = \{a,a,a,b,c,c,d,d,d,d\}\) = \(\{3\cdot a, 1\cdot b, 2 \cdot c, 4 \cdot d\}\) 一般把多重集合记为 \(M = \{k_1\cdot a_1, k_2\cdot a_2, \ldots, k_n \cdot a_n\}\), 定理 多重集合 \(M = \{\infty\cdot a_1, \infty\cdot a_2, \ldots, \infty \cdot a_k\}\) 的 r 排列数为 \(k ^ r\) 这个..勉勉强强吧 定理 多重集合\(M = \{k_1\cdot a_1, k_2\cdot a_2, \ldots, k_n \cdot a_n\}\) 的全排列数为 \[\frac{(k_1 + k_2 + \ldots + k_n)!}{k_1!k_2!\ldots k_n! }\] 多重集合的组合 定理 多重集合 \(M = \{\infty\cdot a_1, \infty\cdot a_2, \ldots, \infty \cdot a_k\}\) 的 r 组合数为 \(\binom{k+r-1}{r}\), 另一种描述 将 r 个相同的求放入 k 个不同的盒中. 定理 多重集合 \(M = \{\infty\cdot a_1, \infty\cdot a_2, \ldots, \infty \cdot a_k\}\) 要求 \(a_1, \ldots, a_k\) 至少出现一次的 \(r\) 组合数为 \(\binom{r-1}{k-1}\) 高中时的“隔板法” 二项式定理 二项式定理 $(x + y)^n = _{r=0}^{n} x^{n-r} y ^r $ 二项式定理 \(,(1+x)^{\alpha} = \sum_{r=0}^{\infty}\binom{\alpha}{r} x^r\) for all \(\alpha \in \mathbb{R}\) , \(\binom{\alpha}{r} = \frac{\alpha(\alpha -1)\ldots(\alpha-r+1)}{r!}\) 当 \(\alpha= - n\), \[\begin{align} \binom{\alpha}{r} &amp; = \binom{-n}{r} \\ &amp;= \frac{(-n)(-n-1)\ldots(-n-r-1)}{r!} \\ &amp;= (-1)^r\binom{n+r-1}{r} \end{align}\] so, \((1+x)^{-n} = \sum_{r=0}^{\infty}(-1)^r \binom{n+r-1}{r} x^r\) 当 \(\alpha = \frac{1}{2}\), \[\begin{align}\binom{\alpha}{r} &amp;= \binom{\frac{1}{2}}{r} \\ &amp;=\frac{\frac{1}{2}(\frac{1}{2}-1)\ldots(\frac{1}{2}-r+1)}{r!}\\&amp;=(-1)^{r-1}\cdot\frac{1}{r2^{2r-1}}\binom{2r-2}{r-1} \end{align}\] so, \[(1+x)^\frac{1}{2} = \sum_{r=0}^{\infty}(-1)^{r-1}\frac{1}{r2^{2r-1}}\binom{2r-2}{r-1}x^r\] \(\binom{n}{r}\) 的一些基本性质: 对称 递推关系 单峰(中间最大) 可以看做在杨辉三角中, 从顶点走到\(\binom{n}{r}\) 点的所有路径数. 恒等式: \(\binom{n}{0} + \binom{n}{1} + \ldots + \binom{n}{n} = 2^n\) \(\binom{n}{i}\) 所有偶数项求和等于所有奇数项 \(1\binom{n}{1} + 2\binom{n}{2} + 3\binom{n}{3} + \ldots + n\binom{n}{n} = n2^{n-1}\), 证明: \((1+x)^n\) 在 \(x=1\) 处求导. \(\sum_{k=0}^{n}\binom{n}{k}^2 = \binom{2n}{n}\) \(\binom{0}{k}+\binom{1}{k} + \ldots + \binom{n}{k} = \binom{n+1}{k+1}\), 组合意义, \(\sum_{k=0}^{n}\binom{n}{k}^2 = \binom{n}{0}\binom{n}{n} + \binom{n}{1}\binom{n}{n-1} + \ldots + \binom{n}{n}\binom{n}{0}= \binom{2n}{n}\), 组合意义 \(\sum_{i=0}^{r}\binom{m}{i}\binom{n}{r-i} = \binom{m+n}{r}\) , Vandermonde 恒等式, 上式的推广 \(\sum_{i=0}^{m}\binom{m}{i}\binom{n}{r+i} = \binom{m+n}{m+r}\), 多项式定理 \((x_1+ x_2+ \ldots + x_t)^n = \sum\binom{n}{n_1n_2\ldots n_t}x_1^{n_1}x_2^{n_2}\ldots x_t^{n_t}\) 多项式系数 \(\binom{n}{n_1n_2\ldots n_t} = \frac{n!}{n_1!n_2!\ldots n_t!}\) 容斥定理 \(S\) 是有限集合, \(P_1 ,P_2,\ldots,P_m\) 是有关 \(S\) 元素的性质, \(A_i\) 是 \(S\) 中具有 \(P_i\) 性质的元素组成的集合, 则 \(S\) 中不具有性质 \(P_1,\ldots,P_m\) 的元素个数为: \[ |\overline{A_1} \cap \overline{A_2} \cap \ldots \cap \overline{A_m}| = |S| - \sum|A_i| + \sum|A_i\cap A_j| - \sum|A_i\cap A_j \cap A_k| + \ldots + (-1)^m |A_1\cap A_2 \cap \ldots \cap A_m|\] 错排问题 1,2,…,n, 的一个错排指满足每个数不在原位置的全排列. 错排数\(D_n = n!(1 - \frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+\ldots+(-1)^n\frac{1}{n!})\) 证明方法1. 容斥定理 $P_i $ 为 i 在原位置上. 2. 递推公式 有禁止模式的排列问题 容斥原理, \(P_i\) 为有某个禁止模式的排列 生成函数 定义 \(A(x) = a_0 + a_1x + a_2x^2 + \ldots\) 为序列 \(a_0, a_1, a_2, \ldots\) 的生成函数. 加法, 对应项相加 \(A(x)+B(x) \equiv \sum_{k=0}^\infty (a_k + b_k)x^k\) 乘法, 相乘后合并同次项 \(A(x)B(x) \equiv \sum_{k=0}^{\infty} (a_kb_0+a_{k-1}b_1+ \ldots + a_0b_k)x^k\) 加法零元: 0, 0, 0, … 乘法单位元: 1, 0, 0, … 形式多项式集合 \(R[[x]]\) 构成一个整环. 求导 生成函数的性质 一些计算规则和例子 \(b_k = \sum_{i=0}^k a_i\) \(\iff\) \(B(x) = \frac{A(x)}{1-x}\) \(b_k=\sum_{i=k}^\infty a_i \iff B(x) = \frac{A(1)-xA(x)}{1-x}\) \(b_k = ka_k \iff B(x) = xA&#39;(x)\) \(b_k=\frac{a_k}{k+1} \iff B(x) = \frac{1}{x}\int_0^xA(t)\,\mathrm{d}t\) 组合型分配问题的生成函数 \(\{\infty a_1, \infty a_2, \ldots, \infty a_n\}\), 的 \(k\) 组合数 其生成函数 \(A(x) = (\sum_{i=0}^\infty x^i )^n\) , 每个因子 \(\sum_{i=0}^\infty x^i\) 表示一个 a_i 可取的个数, 生成函数的 \(k\) 次项就是 \(k\) 组合数. \(A(x) = \frac{1}{(1-x)^n}\), \(a_k = \binom{n-1+k}{k}\) 排列型分配问题的指数型生成函数 指数型生成函数. 数列 \(a_i\), 的指数型生成函数为 \(\sum_{k=0}^\infty a_k \frac{x^k}{k!}\) 正整数拆分 递推关系 常系数线性齐次递推关系 常系数线性非齐次 迭代归纳法 生成函数求解递推关系 特殊计数序列 fibonacci catalan 集合划分 stirling 分配问题 Polya 计数 群 非空集合\(G\) 以及在上面的二元运算 \(\cdot\), 满足以下条件 运算封闭 结合律成立 存在单位元 每个元素都存在逆元 则称 \(\langle G, \cdot \rangle\) 为群. 由以上几条,可以证明的一些性质: 设\(\langle G, \cdot \rangle\) is a group, \(e\) is the identity element. then: \(e^{-1} = e\) \(e\) is unique 消去律成立, if \(a \cdot b = a \cdot c\) or \(b \cdot a = c \cdot a\) then \(b = c​\) \((a \cdot b)^{-1} =b^{-1} \cdot a^{-1}\) 定义子群, 设 \(\langle G, \cdot \rangle\) is a group, and \(H\) is a non-empty subset of \(G\), if \(\langle H, \cdot \rangle\) is a group, we call it \(G\)’s subgroup 一些性质包括, 只要 \(H\) 中运算封闭, \(\langle H, \cdot \rangle\) 就是子群. 置换群 有限集合\(D\) 上的 一一映射 成为 \(D\) 上的置换. 不失一般性, \(D=\{1,2,\ldots, n\}\) 一个置换 \(\sigma = \left ( \begin{array}{cccc}1&amp;2 &amp;\ldots &amp; n\\ \sigma(1) &amp;\sigma(2) &amp;\ldots &amp; \sigma(n)\end{array} \right )\) 将1 映射到 \(\sigma(1)\), 以此类推. \(D = \{1, 2,\ldots, n\}\) 的所有置换构成一个群, 记为\(S_n\), \(\big|S_n\big| = n!\) \((1,4,6)\) 这种叫轮换, \(1\to4, 4\to 6, 6 \to 1\), 其他不变. 举个例子, 轮换的复合运算: \((1234)(1234) = (13)(24)\) 任意置换都可以表示为不相交的轮换之积. \(D\) and \(R\) are two finite sets, \(F = D \to R\), \(G\) is a Permutation Group on D, for some \(f1_1, f_2 \in F\), if there exists \(\sigma \in G\), s.t. forall \(d \in D\), \[ f_1(d) = f_2(\sigma(d))\] We call \(f_1\) and \(f_2\) are \(G\) equal (\(G\) 等价) 两个映射 \(f_1\), \(f_2\) 在 置换群\(G\) 上等价, 如果存在一个定义域上的一一映射, 把定 义域的元素用这个映射换一下 \(f_1\) 就是 \(f_2\). 显然这个关系是\(F\) 上的一个等价关系 (和 \(G\) 好像并没有什么关系)? 并不是和\(G\) 没有关系哟. 如果给定一个置换群G, 那么就能把 \(F, (F = D \to R)\) 划分成 多个等价类. 对应到组合问题中, 比如一个着色方案, 一个分配方案, 实际上就是一个\(F = D \to R\), 着色方案的话, \(D\) 是定点, \(R\) 是颜色. 分配方案的话, \(D\) 是小球, \(R\) 是盒子. 给定一个置换群\(G\), 等价类的个数就是实际的组合方案数. Burnside 引理 定义两个置换的共轭: \(G\) is subgroup of \(S_n\), two elements \(s, t \in S_n\), if there exists a \(g \in G\), s.t. $s = g^{-1} t g $, then we say \(s\) is a conjugate of \(t\), and that viceversa, or \(s\) and \(t\) of \(G\) are conjugate. G-conjugate, G共轭是 \(S_n\) 上的一个等价关系. G共轭当且仅当, 两个置换是同型的. 定义同型: 映射的等价类 Burnside引理 可以解决用m色对n个物体着色的方案计数问题, 但是计算量太大, 经过 Polya 改进形成 Polya 计数定理后才得到广泛应用. 组合设计]]></content>
  </entry>
  <entry>
    <title><![CDATA[randomized algorithm]]></title>
    <url>%2F2017%2F12%2F11%2Frandomized-algorithm%2F</url>
    <content type="text"><![CDATA[概率算法 总结 基本概念 确定算法的平均执行时间: 一定输入规模的所有输入实例等概率出现时, 平均时间. 概率算法期望执行时间: 在某一个输入实例上的期望时间 概率算法的平均期望时间: 所有输入实例等概率的期望时间 概率算法的最坏期望时间: 最坏的输入实例上的期望时间 概率算法分类 Numerical 数值积分 Monte Carlo 给出一个答案，未必正确 Las Vegas 答案必定正确，耗时任意长, 可能_没有答案_. 比如吧 MenteCarlo 算法反复执行, 直至正确. Sherwood 总是给出正确的答案, 把一个确定性算法随机化, 可以降低算法的最坏时间复杂度 数值积分 HitorMiss 算法 面积法, 长方形下函数面积 在长方形区域取样, 计算有多少比例的点在函数下. Crude 算法 积分区间函取值的平均. 梯形积分 概率計数 求集合的勢 设 \(|X| = n\) , 有放回地随机抽元素, 设 \(k\) 是出现第一次重复之前所选的元素数目. 则当 \(n\) 足够大时, \(k\) 的期望趋近于 \(\beta \sqrt{n}\) , \(\beta = \sqrt{\pi / 2} \approx 1.253\) \(\beta\sqrt{n} = k\), 时间复杂度 \(\Theta(\sqrt{n})\) , 空间复杂度 \(\Theta(\sqrt{n})\). 向量中不同对象数目的估计 例如,磁带上记录有莎士比亚全集, 统计其中使用了多少不同的单词. \(N\) 是总单词书, \(n\) 是不同词个数. 设 \(U\) 是单词序列的集合, 设 \(m = 5 + \lceil lg M \rceil\) let \(h : U \mapsto \{0,1\}^m\) be a hash function. 将单词映射为长度为 \(m\) 的串. \(y \in \{0,1\}^k\), \(y[i]\) denotes the \(i\)th bit. Define $ (y, b), b{0,1}$ 表示满足 \(y[i] = b\) 的最小的 \(i\), 如果不存在, 返回 \(k+1\) 算法 WordCount() 用一个长为 \(m+1\) 的向量 \(y\) 统计所有单词的哈希. 单词 \(x\), set \(y[\pi(h(x), 1)]\) to 1 ==TODO== 时间 \(O(n)\) , 空间 \(O(\lg{}n)\) Sherwood 算法 Sherwood 算法, 平滑不同输入实例的执行时间. 把一个确定性算法随机化, 可以降低算法的最坏时间复杂度. 一般 Sherwood 算法的组成: 将输入变换到一个随机实例 用确定算法得到随机实例的解 将随机实例的解变换回原输入的解 例如快排 , 在特定输入下时间复杂度\(O(n^2)\), 可以吧把输入变换到一个随机实例上. 例: 离散对数的计算. ​ $ a = g^x p$ , 已知p, g, a, 求 x, 记为 \(\log_{g,p} a\) 确定算法: \(\forall x \in \mathbb{Z}_p\) 计算所有的 \(g^x\) 与 a 比较. 最坏为 \(O(p)\) 例: 搜索有序表.找x 随机找一个开始. 如果大于 x, 重来, 如果小于 x, 从这里开始顺序查找. 找 (前) \(\sqrt{n}\) 个元素, 从小于 x 且最接近 x 的开始顺序查找. (对有序表的数据结构有要求) Las Vegas 算法 时间上界可能不存在, (像扔硬币, 如果结果不是正面就再扔). 假设 try(x) 成功的概率为 p(x), 成功的期望时间s(x), 失败时期望时间e(x) 123obstinate() &#123; while (!try(x))&#125; obstinate(x) 一定会成功, 设期望时间为t(x) \(t = ps + (1-p)(e+t)\) \(t = s + \frac{1-p}{p}e\) 八皇后 模 p 平方根 说实话, 课程PPT 实在是太糟糕了. 定义 \(p\) is an (odd?, in course PPT, no problem, only ‘2’ is even) prime, if \(x \in [1, p-1]\), and for some y, \[ x = y^2 \mod p\] x is a quadratic residue modulo \(p\), and y is the square root of x. wiki: an interger \(q\) is called a quadratic reside modulo \(n\) if it is congruent to a perfect square module \(n\) Theorem: every quadratic residue module \(p\) has at least two different square root. proof: easy, if \(x_0^2 = y \mod p\) then \((p-x_0)^2 = y \mod p\). Theorem: every quadratic residue module \(p\) has at most two different square root. proof: \[ \begin{align} a^2 = b^2 \mod p \\ a^2 - b^2 \mod p \\ p | (a+b) (a-b) \\ \end{align} \] Theorem: half of \(\{1,2,\ldots, p-1\}\), is quadratic residue module \(p\). proof: every quadratic residue modulo \(p\) has two square root, [1, p-1] (f x : x*x maps two from range to one in the image, and no overlap) I’ll just write \(=_p\) instead of \(\mod p\) Theorem \(p\) is an odd prime, \(x^{(p-1)/2} =_p \pm 1\) and \(x\) is a quadratic residue modulo \(p\) iff !!! PPT error!! Maybe its: \(x^{(p-1)/2} =_p \pm 1\) iff \(x\) is a quadratic residue modulo \(p\)? I think so. proof by \(x^{(p-1)} =_p 1\), the Fermat Theorem This can be used to check if a number is a quadratic residue. Question: How to compute \(x\)’s square roots given it is a quadratic residue? if \(p = 3 \mod 4\), they are \(\pm x^{(p+1)/4}\) if \(p = 1 \mod 4\), there is no effeient determinat algorithm Las Vegas algorithm: We use \(\sqrt{x}\) to denotes the smaller one of its square roots TODO 整数因数分解 \(n\), 求 \(n = p_1^{m_1} p_2^{m_2} \ldots p_k^{m_k}\) 首先是素数判定, prime(n), 如果是合数, split(n), 找到 \(n\) 的一个非平凡因数. naive way to to split. test all number from 2 to \(\sqrt{x}\). Dixon 这里我们把 二次剩余, quadratic residue 推广到合数. 一个模 \(p\) 的二次剩余, 当 \(p\) 为素数时, 恰好有两个不同的平方根; 当 \(p\) 为合数, 且至少有**两个奇素数因子时, 不是这样. 例如 \(8^2 = 13^2 = 22^2 = 27^2 = 29 \mod 35\) Theorem: If \(x\) is a quadratic residue of \(q\), then \(x\) and \(q\) are relatively prime Theorem: If \(n= pq\), \(p\) and \(q\) are two different primes, then every quadratic residue of \(n\) has exactly 4 square roots. 素数测定 ​ Monte Carlo 算法 Monte Carlo 算法偶尔会犯错, 但无论对何实例都能以高概率找到正确解(?), 当算法出错时, 没有警告信息. Def 设 \(p \in (\frac{1}{2}, 1)\) if an MC algorithm 以不小于 p 的概率返回一个正确解, 则该MC算法称为 p-正确. 算法的优势(advantage) 为 \(p - \frac{1}{2}\) Def 若一个MC 算法对同一个实例不会给出两个不同的正确解, 则称该算法为 consistent. Def 偏真算法, 设 MC(x) 为一个解判定问题的算法. 对于任何 x, 如果 MC(x) 返回 true 时 永远是正确的, 返回 false 时 可能是错的. Def 偏\(y_0\)算法, 更一般的, 返回结果是 \(y_0\) 就肯定是对的. 主元素问题 参考 中科大算法分析与设计的总结 | 百度文库]]></content>
  </entry>
  <entry>
    <title><![CDATA[Write a Parser in OCaml]]></title>
    <url>%2F2017%2F06%2F25%2Fparser-in-OCaml%2F</url>
    <content type="text"><![CDATA[First we define the language, then translate it into OCaml code. Definition Two part is necessary, 1. Syntax Definition in Bacus-Naur Form to define the “Language”(which is, set of string). 2. And sematics definition to Describe the “Meaning”. Syntax Definition Including lexing and parsing rules. 123&lt;start&gt; ::= &lt;exp&gt; &apos;\n&apos;&lt;exp&gt; ::= &lt;exp&gt; &lt;op&gt; &lt;exp&gt; | [&quot;0&quot;-&quot;9&quot;]+&lt;op&gt; ::= &quot;+&quot; | &quot;-&quot; Sematics Definition This is the AST(Abstract Syntax Tree) definition, sine we want to write a frontend for a compiler. 12type op = Plus | Minus type exp = Exp of exp * op * exp | Num of int Implementation We need to implement four parts part file method lexer lexer.mll ocamllex parser parser.mly ocamlyacc AST ast.ml by hand, some lib for pretty printing driver driver.ml by hand Translate language definition to code In our Bacus-Naur Form definition, those symbols quoted with ' &quot; should be denoted as Lexeme simble. and defined in the parser.mly file. 123&lt;start&gt; ::= &lt;exp&gt; &apos;\n&apos;&lt;exp&gt; ::= &lt;exp&gt; &lt;op&gt; &lt;exp&gt; | [&apos;0&apos;-&apos;9&apos;]+&lt;op&gt; ::= &quot;+&quot; | &quot;-&quot; \(\Downarrow\) 123456789// regular grammar&lt;EOL&gt; ::= &apos;\n&apos;&lt;NUM&gt; ::= [&apos;0&apos;-&apos;9&apos;]+&lt;PLUS&gt; ::= &quot;+&quot;&lt;MINUS&gt; ::= &quot;-&quot;// context free grammar&lt;start&gt; ::= &lt;exp&gt; &lt;EOL&gt;&lt;exp&gt; ::= &lt;exp&gt; &lt;op&gt; &lt;exp&gt; | &lt;NUM&gt;&lt;op&gt; ::= &lt;PLUS&gt; | &lt;MINUS&gt; Regular grammar tokens are defined in the header of parser.mly, like this 1234%token &lt;int&gt; NUM%token PLUS MINUS%token EOL%left PLUS MINUS and produced by lexer.mll, like this 1234567rule token = parse [&apos; &apos; &apos;\t&apos;] &#123; token lexbuf &#125; | &apos;\n&apos; &#123; Parser.EOL&#125; | [&apos;0&apos;-&apos;9&apos;]+ as i &#123; Parser.NUM(int_of_string i) &#125; | &apos;+&apos; &#123; Parser.PLUS &#125; | &apos;-&apos; &#123; Parser.MINUS &#125; | eof &#123; raise Eof &#125; Context free grammar are put in the main part of the parser.mly The AST part can be put in the ast.ml file directly. Some utility function for error handling and pretty printing can be put here.]]></content>
  </entry>
  <entry>
    <title><![CDATA[始まりの物語]]></title>
    <url>%2F2017%2F03%2F01%2F%E5%A7%8B%E3%81%BE%E3%82%8A%E3%81%AE%E7%89%A9%E8%AA%9E%2F</url>
    <content type="text"><![CDATA[新的开始 原来的文章写得毫无意义，而且更新了 hexo 之后连编译都过不了了。于是从零开始。 其实我更喜欢 LaTeX 的，这里只能用 MarkDown 和 HTML)。 等等！如果能够使用 HTML, 那么 Javascript 。。。。 Click? O__O \(o)/~ (ノಠ益ಠ)ノ彡┻━┻ ( ⊙ o ⊙ ) (ˇˍˇ) ┑(￣Д ￣)┍ 厉害了，图灵完备! 可以在这里放 JS 游戏了。。。 打算写些什么 日记有 OneNote，笔记和实验室做的事情用 Latex 记着，这里要写的话，就剩下课程和实 验室工作以外的东西了，比如个人兴趣之类的。 博客 引擎 Hexo, markdown 生成静态网页，轻松部署到 Github。 主题 NexT 评论 disqus, 多说评论挂了，Disqus 需要翻墙。 Markdown 功能测试 H3 H4 H5 H6 基本 markup normal ita ita bold underscores, strikethrough jump to google item item li li a * b, a_b , a\b 数学公式 MathJax Ref 新版本需要在frontmatter 里面加上 mathjax: true 才会加载 mathjax. inline formulas: $a = \sum_{i=1}^{n} x_i$ \(a = \sum_{i=1}^{n} x_i\) displayed formulas: $$ \alpha ::= \tau \times \lambda $$ \[ \alpha ::= \tau \times \lambda \] Warning! 默认 markdown 编译器是 hexo-renderer-marked, 对于\\ * _ 的翻译有 bug, BUG: 混合 _ and $ 1$a_1, a_2$ \(a_1, a_2\) 1$a_0 a_&#123;n-1&#125;$ \(a_0 a_{n-1}\) 换一个renderer，在 hexo 插件页上有几个选择。 hexo-renderer-pandoc, 没问题了。 还有一个 hexo-renderer-markdown-it, 没试. 1$a\_0 a\_&#123;n - 1&#125; $ $a_0 a_{n - 1} $ \(a\_0\) Tables Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码 incline code 12345678(* invariant: *)(* x,y = exgcd(a,b) *)(* ax + by = gcd(a,b) *)let rec exgcd(a,b) : int * int = if a mod b = 0 then 0, 1 else let x,y = exgcd(b, a mod b) in y, x - y * (a/b);;]]></content>
      <tags>
        <tag>self-referencing</tag>
      </tags>
  </entry>
</search>
