<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web Server using NodeJS]]></title>
    <url>%2F2018%2F03%2F26%2FWeb-Server-using-NodeJS%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Inference on Embeded Systems]]></title>
    <url>%2F2018%2F03%2F14%2FInference-on-Embeded-Systems%2F</url>
    <content type="text"><![CDATA[Sparsification and Separation. key Contributions: * A sparse coding-based approach to optimize depp learning inference execution. * Convolution kernel separation technique * The first to do Deep Learning Model on severely constrained wearable hardware. * implement a prototype, * experiment with for CNN and DNN models, 11.3x improvements in memory and 13.3x inexecution time. accuracy loss 5% background: DNN, CNN(DNN with some convolutional layers) local computation: privacy, independent of network condition. Design Goals: * No re-training * No Cloud Offloading * Low-resource platforms. only a few MBs of RAM. * Minimize Model Changes Three technique: * Layer Compression Compiler, for Fully-connected layers * Sparse Inference Runtime, load active layers only * Convolution Separation Runtime, for Convolutional layers. Fully-connected layers: \(f(\mathbf{b} + \mathbf{W} \cdot \mathbf{x})\) Convolutional Layers: \(f(\sum\mathbf{x} \ast \mathcal{K} + \mathbf{b} )\) Weight Factorization: \(W \cdot x\) , \(W\) is m x n, if we factorize \(M = U \cdot V\), \(U\) and \(V\) is m x k, then compressed. Previous work use SVD. This paper improved this by using Dictionary Learning. factorized \(M = B \cdot A\), \(A\) is a sparse matrix. Convolutional Layers: d x d convolutional kernels factorized to d x k and k x d, use SVD. choose k for specified accuracy, memory, and computation time: for each layer, use binary search to find one. evaluation:]]></content>
  </entry>
  <entry>
    <title><![CDATA[File Server on Ubuntu]]></title>
    <url>%2F2018%2F03%2F14%2FFile-Server-on-Ubuntu%2F</url>
    <content type="text"><![CDATA[Install samba. configure it. Use Samba on the LAN, FTP over the Internet. File Server | Ubuntu documentation 其实把东西记在博客里一点也不方便. 后来某天想要在树莓派上设置Samba时, 还以为是记在 Note 里面的. 找不到这篇笔记, 才 想起是放在了这里.. /etc/samba/smb.conf Official doc for ubt17 is not released yet. I made some change in the [homes] section. 1234567[homes] comment = Home Directories browseable = yes read only = no create mask = 0775 directory mask = 0775 valid users = %S then sudo service smdb restart &amp;&amp; service nmbd restart add user to sambda smbpasswd -a &lt;user-name&gt;]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Network Simulator: ns-3]]></title>
    <url>%2F2018%2F03%2F14%2FNetwork-Simulator-ns-3%2F</url>
    <content type="text"><![CDATA[ns-3 is a Network simulator, preparation Normally you need to download the source and build it. Compile failed on MacOS, So I have to use Ubuntu. Download ns-allinone-3.27.tar.bz2. Then tar xf it, and build it: 1./build.py --enable-examples --enable-tests or ./waf -d optimized --enable-examples --enable-tests configure run example ./waf --run hello-simulator in example/tutorial Concepts four basic Concepts: Node: a machine, pc, router, switch Application: program Channel: between nodes csma, p2p, wifi NetDevice: Network interface Card and driver. Topology Helper: attach NetDevice to Node and Channel, do configuration NodeContainer create, access and manage Node objects]]></content>
  </entry>
  <entry>
    <title><![CDATA[ML-oxford]]></title>
    <url>%2F2018%2F01%2F12%2FML-oxford%2F</url>
    <content type="text"><![CDATA[linear \(\hat{y} = \mathrm{X} \theta\) \(X = \begin{bmatrix} x_{11}\end{bmatrix}\) \(J(\theta) = (y - X\theta)^T (y - X\theta) = \sum_{i=1}^{n}(y_i - x_i^T\theta)^2\) matrix differentiation.]]></content>
  </entry>
  <entry>
    <title><![CDATA[pathfinding]]></title>
    <url>%2F2018%2F01%2F09%2Fpathfinding%2F</url>
    <content type="text"><![CDATA[A pathfinding method searches a graph by starting at one vertex and exploring adjacent nodes until the destination node is reached. Two primary problems of pathfinding are (1) to find a path between two nodes in a graph; and (2) the shortest path problem—to find the optimal shortest path. Basic algorithms such as breadth-first and depth-first search address the first problem by exhausting all possibilities; starting from the given node, they iterate over all potential paths until they reach the destination node. These algorithms run in \(O(|V|+|E|)\), or linear time, where V is the number of vertices, and E is the number of edges between vertices. The more complicated problem is finding the optimal path. The exhaustive approach in this case is known as the Bellman–Ford algorithm, which yields a time complexity of \(O(|V||E|)\), or quadratic time. However, it is not necessary to examine all possible paths to find the optimal one. Algorithms such as A*and Dijkstra’s algorithm strategically eliminate paths, either through heuristics or through dynamic programming. By eliminating impossible paths, these algorithms can achieve time complexities as low as \(O(|E|\log⁡(|V|))\). The above algorithms are among the best general algorithms which operate on a graph without preprocessing. However, in practical travel-routing systems, even better time complexities can be attained by algorithms which can pre-process the graph to attain better performance. One such algorithm is contraction hierarchies. Bellman-Ford algorithm Dijkstra’s algorithm begins with a start node and an “open set” of candidate nodes. At each step, the node in the open set with the lowest distance from the start is examined. The node is marked “closed”, and all nodes adjacent to it are added to the open set if they have not already been examined. This process repeats until a path to the destination has been found. 算法会找到从起始顶点到每个顶点(距离小于起始顶点到目标顶点最短路径)的最短路径. Dijkstra’s algorithm fails if there is a negative edge weight. A* algorithm Sample algorithm 1234567891011121314151617181920212223 1 2 3 4 5 6 7 8X X X X X X X X X XX _ _ _ X X _ X _ X 1X _ X _ _ X _ _ _ X 2X S X X _ _ _ X _ X 3X _ X _ _ X _ _ _ X 4X _ _ _ X X _ X _ X 5X _ X _ _ X _ X _ X 6X _ X X _ _ _ X _ X 7X _ _ O _ X _ _ _ X 8X X X X X X X X X X 1 2 3 4 5 6 7 8X X X X X X X X X XX _ _ _ X X _ X _ X 1X _ X _ _ X _ _ _ X 2X S X X _ _ _ X _ X 3X 6 X 6 _ X _ _ _ X 4X 5 6 5 X X 6 X _ X 5X 4 X 4 3 X 5 X _ X 6X 3 X X 2 3 4 X _ X 7X 2 1 0 1 X 5 6 _ X 8X X X X X X X X X X]]></content>
  </entry>
  <entry>
    <title><![CDATA[distributed algorithm]]></title>
    <url>%2F2018%2F01%2F08%2Fdistributed-algorithm%2F</url>
    <content type="text"><![CDATA[分布式算法 模型： 异步共享存储 异步msg传递 同步msg传递 拓扑：无向图，节点为处理机，边喂双向信道. 算法：由每个处理器上的局部程序构成，包括本地计算和收发msg 节点 \(p_i\), \(p_i\) 相邻的边 \(r\) 条. \(p_i\) 有两个 buffer list: \(outbuf_i[l]\) , \(inbuf_i[l]\), \(l \in [1, r]\) 配置：某时刻，算法运行的全局状态。为一个向量 \((q_0, \ldots, q_{n-1})\), \(q_i\) 是 \(p_i\) 的状态. 状态 事件：两种 \(comp(i)\), 计算事件. \(del(i,j,m)\), 传递事件，将msg \(m\) 从 \(p_i\) 传递到 \(p_j\). 转换函数 执行: 配置和事件交错的序列。 Safety 条件。 (用来证明算法正确性吗?) 该条件在每个有限前缀里的都成立 Liveness 条件。 必须成立一定次数。 满足所有安全性条件的序列称为一个执行, 满足所有活跃性条件的 执行 为 容许(admissible) 的执行。 下面主要考虑异步msg传递系统。 执行片段 \(\alpha\) 是一个有限或无限的序列: \[ C_0, \Phi_1, C_1, \Phi_2, C_2, \ldots, \] 其中 \(C_k\) 是一个配置, \(\Phi_k\) 是一个事件. 如果 \(\alpha\) 有限, 则它必须结束于某个配置, 且需满足下述条件: 若 \(\Phi_k = del(i,j,m)\), 则 \(m\) 必须是 \(C_{k-1}\) 时 \(outbuf_i[l]\) 的元素. \(l\) 是 \(p_i\) 信道 \({p_i, p_j}\) 的标号. 从 \(C_{k-1}\) 到 \(C_k\) 的唯一变化是将 \(m\) 从 \(C_{k-1}\) 里的 \(outbuf_i[l]\) 中 删去, 加入到 \(C_k\) 的 \(inbuf_i[h]\), \(h\) 是 \(p_j\) 的信道 \({p_j, p_i}\) 的标号. 若 \(\Phi_k = comp(i)\), 则 \(C_{k-1}\) 到 \(C_k\) 的变化是 改变状态: 转换函数在\(p_i\) 的可访问状态(在配置\(C_{k-1}\)里)上进行操作，清空 \(inbuf_i[l]\)，\((1≤l≤r)\) 发送 msg: 将转换函数制定的消息集合加入 \(C_k\) 里的变量 \(outbuf_i\) 上 调度 , 调度(或调度片段)总是和执行(或执行片段)联系在一起, 它是执行中的时间序列: \[ \Phi_1, \Phi_2, \ldots\] 并不是每个事件序列都是调度. 例如, \(del(1,2,m)\) 不是调度, 因为在此时间之前, \(p_1\) 没有 send m. 若局部程序是确定的, 则执行(或执行片段)由 初始配置 \(C_0\) 和调度(或调度片段) \(\sigma\) 唯一确定, 可表示为 \(exec(C_0, \sigma)\) 容许执行: 满足活跃性条件的执行. 容许调度: 容许执行的调度. 同步系统, 同步模型中, 执行分为轮, 每轮里, (1)每个处理器能够发送一个 msg 到每个邻居 (2) 每个处理器一接到 msg 就进行计算. 轮 同步系统中, 每轮由一个传递时间(outbuf发送, 清空), 紧跟一个计算时间 (处理所有msg) 终止, 所有处理机均处于终止状态且没有msg 在传输. msg复杂度 实际很少用状态转换来描述算法, 往往用伪码描述. 生成树]]></content>
  </entry>
  <entry>
    <title><![CDATA[approximate algorithm]]></title>
    <url>%2F2018%2F01%2F08%2Fapproximate-algorithm%2F</url>
    <content type="text"><![CDATA[近似算法 总结 [TOC] NP-completeness 可计算 计算模型 Church-Turing Halt(Program, input) 确定型图灵机 非确定型图灵机sa P类问题: 一类问题的集合, 对其中的任一问题, 都存在 一个确定型图灵机 \(M\) 和一个多项式 \(p\), 对于该问题的任何(编码)长度为\(n\) 的实例, \(M\) 都能在 \(p(n)\) 步内, 给出回答. 即多项时间内可解的问题 NP类问题: 一类问题的集合, 对其中的任一问题, 都存在一个非确定型图灵机 \(M\) 和 一个多项式\(p\), 对该问题的任何(编码)长度为 \(n\) 的实例, \(M\) 都能在 \(p(n)\) 步内, 给出对该实例的回答. 若 NTM]]></content>
  </entry>
  <entry>
    <title><![CDATA[paralell computing]]></title>
    <url>%2F2018%2F01%2F05%2Fparalell-computing%2F</url>
    <content type="text"><![CDATA[paralell data dependency statement S, T, define \(S \,\delta\, T\): \(T\) depends on \(S\), \(S\) must be executed before \(T\) \(S\,\delta\,T\) if and only if one of the cases are true. \(x\) is a variable flow dependency: \(S\,\delta^f\,T\), if \(x \in OUT(S)\), and \(x \in IN(T)\). and \(x\) is readed in \(T\) S: x = a + b T: y = x Read after wrtie. reverse dependency: \(S\,\delta^a\,T\), if \(x \in IN(S)\) and \(x \in OUT(T)\). and \(S\) read \(x\) before \(T\) write to \(x\) S: r = x T: x = a + b Write after read. output dependency: \(S\,\delta^o\,T\), if \(x \in OUT(S)\) and \(x \in OUT(T)\). \(S\) write to \(x\) before \(T\) write to \(x\). S: x = a T: x = b Write after write.]]></content>
  </entry>
  <entry>
    <title><![CDATA[network security]]></title>
    <url>%2F2018%2F01%2F03%2Fnetwork-security%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[DWT]]></title>
    <url>%2F2018%2F01%2F01%2FDWT%2F</url>
    <content type="text"><![CDATA[离散小波变化.]]></content>
  </entry>
  <entry>
    <title><![CDATA[eigen]]></title>
    <url>%2F2017%2F12%2F30%2Feigen%2F</url>
    <content type="text"><![CDATA[计算矩阵的全部特征值的 QR 方法 QR 分解指, 将矩阵 \(A\) 分解为 \(A = QR\), \(R\) 是上三角矩阵, \(Q\)是正交矩阵. 利用QR分解求矩阵特征值的方法如下: \(A_1 = Q_1 R_1\) \(A_2 = Q_1^{-1} A_1 Q_1 = Q_1^{-1}Q_1 R_1 Q_1 = R_1 Q_1\) 即分解后交换 QR 再相乘, 反复迭代这回收敛到以A 的特征值为对角线元素的上三角矩阵. 并行算法就是将 QR 分解和矩阵相乘的两个步骤并行化. 离散小波变换 DWT]]></content>
  </entry>
  <entry>
    <title><![CDATA[string match]]></title>
    <url>%2F2017%2F12%2F13%2Fstring-match%2F</url>
    <content type="text"><![CDATA[问题, Pattern, \(P : \Sigma^m\), Text \(T : \Sigma^n\) \(n \ge m\), 找 P 在 T 中的位置. Hash 函数 \(hash\) , 求 \(hash(P)\), 与 \(T\) 的所有长度 \(m\) 的子串. 先比较 Hash, 如果 hash 值相等, 再精确比较. 要求是 hash 计算得快, 最好是 \(hash(T[i, i+m-1])\) 可以从 \(hash(T[i-1, i+m-2])\) 在 \(O(1)\) 的时间内算出来. 一种是 Rabin-Karp 的, hash 是多项式, \(p\) 是一个素数. \(hash([a_1, a_2, \ldots, a_m]) = a_1 + a_2 \cdot p + a_3 \cdot p^2 + \ldots + a_m \cdot p^{m-1}\) 并行课本上的算法如下. 假设 \(\Sigma = \{0, 1\}\), \[ f(0) = \begin{bmatrix} 1 &amp; 0 \\ 1 &amp; 1 \end{bmatrix}, f(1) = \begin{bmatrix} 1 &amp; 1 \\ 0 &amp; 1 \end{bmatrix}\] 取一个小于 \(M\) 的素数\(p\), \(\mathbb{Z}_p\) 是整数环. \(f_p(X) = f(X) \mod p\), 求 \(f_p(T[i, i+m-1])\) ? 说实话, 书上根本没写清楚怎么算. 猜测应该是矩阵相乘. \(f([a_1, a_2, \ldots, a_m]) = f(a_1) \times f(a_2) \times \ldots \times f(a_m)\) 试一下 123456789101112import numpy as npfrom functools import reducef = [np.empty((2,2), dtype=np.int64)] * 2f[0] = np.array([(1,0), (1,1)])f[1] = np.array([(1,1), (0,1)])def hash(t): return reduce(lambda x,y: x.dot(y), map(lambda x: f[x], t))print(hash([0,1,0,1]))print(hash([1,1,0,1])) 1234[[2 3] [3 5]][[3 5] [1 2]] 而且我们知道 \(f(0)^{-1} = \begin{bmatrix} 1&amp; 0\\ -1&amp; 1\end{bmatrix}\) \(f(1)^{-1} = \begin{bmatrix} 1&amp; -1\\0&amp;1\end{bmatrix}\) 串行执行的话, 使用这个hash, 算法复杂度是 \(O\)(Text的长度) , 我没有看出来上面的 \(f_p\) 模 \(p\) 的必要性. 暂且认为 \(\mod p\) 的目的是防止结果溢出. 课本接下来说, 为了并行处理. 希望 hash算法也并行化. 这要求 hash 函数(对于字符串 连接操作)满足同态, 即 \(hash([T, S]) = hash(X)\cdot hash(Y)\) 显然上面的 \(hash\) 是满足的要求的, 看书上又给出了什么吧: 定义 \[g_p(0) = f_p(0)^{-1} \begin{bmatrix} 1&amp; 0\\ p-1&amp; 1\end{bmatrix}, g_p(1) = f_p(1)^{-1} \begin{bmatrix} 1&amp; p-1\\ 0&amp; 1\end{bmatrix}\] 因为 \(\mathbb{Z}_p\) 中\(p = -1\), 其实上面定义的\(g_p\) 就是 \[g_p(0) = f_p(0)^{-1} \cdot f_p(0)^{-1}, g_p(1) = f_p(1)^{-1} \cdot f_p(1)^{-1}\] \(N_i = f_p(T[1,i])\) \(R_i = g_p(T[i]) g_p(T[i-1])\ldots g_p(T(1))\) 容易看到 \(f_p(T[i, i+m-1]) = R_{i-1} N_{i+m-1}\) 得出的结论就是..课本少写了一个等号(无语), 实际上\(g_p(\cdot) = f_p(\cdot)^{-1}\) 并行算法就是先计算出所有的 \(R_i\) and \(N_i\), 这两个都类似前缀和, 可以并行计算.]]></content>
  </entry>
  <entry>
    <title><![CDATA[组合数学课]]></title>
    <url>%2F2017%2F12%2F12%2Fcombinatorics%2F</url>
    <content type="text"><![CDATA[先是在wiki上找了一下组合数学的词条. 发现涵盖的东西居然这么多. 有机会再看. 这篇只是用来总结课堂的一些知识. 鸽巢原理 定理: 把 n+1 个物体放在 n 个盒子里, 至少有一个盒子里有两个以上的物体. 定理: 鸽巢定理推广. \(q_1, q_2, \ldots, q_n \in \mathbb{Z^+}\) , 把 \(\sum_i q_i - n + 1\) 个物体放入 \(n\) 个盒子, 第一个盒子至少 \(q_1\) 个物体, 或者第二个盒子中至少有 \(q_2\) 个物体, … , 或者第 n 个盒子中至少有 \(q_n\) 个物体. 这两个定理用反证法很容易证明. 课本前半部分都是一些很古典的组合数学问题. 用物体, 盒子等定义不明的语言描述. 这里试着用集合论语言描述一下. 物体集合 O (object), 可数集合 盒子/标签 集合 T (type), 可数集合. 一个方案/安排 a (arrangement), 是一个映射 \(a \in O \to C\), \(O \to C\) 表示所有值域为 \(O\), 定义域为 \(C\) 的映射的集合. 所有方案\(A = O \to C\), 许多问题问的就是 \(|A|\). 鸽巢定理: \(|O| = n+1\), \(|T| = n\), 记 \(A = O \to T\) \(\forall a \in A\) , \(\exists t_0 \in T\), \(|a^{-1}(t_0)| &gt; 1\) 这里用映射的逆表示从值域映射到定义域集合的一个映射. 不得不说, 这么写的话, 定理的含义模糊了很多. 定理的成立也不那么明显了. Ramsey 数 略 排列与组合 加法乘法原则 加法原则: 事件 A 有 m 种选取方式, 事件 B 有 n 种选取方式, 则选择 A 或 B, 有 m + n 中选取方式. 这有什么意义? 太显然了.. 一个事件A 有 m 种选取方式是什么意思? 这里并不涉及上面提到的 Object 和 Type. (因为一时想不到答案.. 走神看QQ去了..). 加法原则可以看做是单纯的集合相加. 看下面的乘法原则吧. 乘法原则: 事件 A 有 m 种选取方式, 事件 B 有 n 种选取方式, 选取 A 然后选取 B 有 mn 中选取方式 这不也仅仅是集合相乘吗.. 减法原则, 除法原则 集合的排列 n 元集合 S 的一个 r 排列是指从 S 中选 r 个元素, 依次排列. 方案数记为 \(P(n,r)\) \[P(n, r) = \frac{n!}{(n-r)!}\] 集合组合 n 元集合 S 的 r 组合是指从 S 中选取 r 个元素的无序选择. 方案数记为 \(\binom{n}{r}\). or \(C_n^r\) \[\binom{n}{r} = \frac{n!}{r!(n-r)!}\] 这个是 S 集合的大小为 r 的子集的个数 多重集合的排列 多重集合里面可能会有相同元素, 比如 \(M = \{a,a,a,b,c,c,d,d,d,d\}\) = \(\{3\cdot a, 1\cdot b, 2 \cdot c, 4 \cdot d\}\) 一般把多重集合记为 \(M = \{k_1\cdot a_1, k_2\cdot a_2, \ldots, k_n \cdot a_n\}\), 定理 多重集合 \(M = \{\infty\cdot a_1, \infty\cdot a_2, \ldots, \infty \cdot a_k\}\) 的 r 排列数为 \(k ^ r\) 这个..勉勉强强吧 定理 多重集合\(M = \{k_1\cdot a_1, k_2\cdot a_2, \ldots, k_n \cdot a_n\}\) 的全排列数为 \[\frac{(k_1 + k_2 + \ldots + k_n)!}{k_1!k_2!\ldots k_n! }\] 多重集合的组合 定理 多重集合 \(M = \{\infty\cdot a_1, \infty\cdot a_2, \ldots, \infty \cdot a_k\}\) 的 r 组合数为 \(\binom{k+r-1}{r}\), 另一种描述 将 r 个相同的求放入 k 个不同的盒中. 定理 多重集合 \(M = \{\infty\cdot a_1, \infty\cdot a_2, \ldots, \infty \cdot a_k\}\) 要求 \(a_1, \ldots, a_k\) 至少出现一次的 \(r\) 组合数为 \(\binom{r-1}{k-1}\) 高中时的“隔板法” 二项式定理 二项式定理 $(x + y)^n = _{r=0}^{n} x^{n-r} y ^r $ 二项式定理 \(,(1+x)^{\alpha} = \sum_{r=0}^{\infty}\binom{\alpha}{r} x^r\) for all \(\alpha \in \mathbb{R}\) , \(\binom{\alpha}{r} = \frac{\alpha(\alpha -1)\ldots(\alpha-r+1)}{r!}\) 当 \(\alpha= - n\), \[\begin{align} \binom{\alpha}{r} &amp; = \binom{-n}{r} \\ &amp;= \frac{(-n)(-n-1)\ldots(-n-r-1)}{r!} \\ &amp;= (-1)^r\binom{n+r-1}{r} \end{align}\] so, \((1+x)^{-n} = \sum_{r=0}^{\infty}(-1)^r \binom{n+r-1}{r} x^r\) 当 \(\alpha = \frac{1}{2}\), \[\begin{align}\binom{\alpha}{r} &amp;= \binom{\frac{1}{2}}{r} \\ &amp;=\frac{\frac{1}{2}(\frac{1}{2}-1)\ldots(\frac{1}{2}-r+1)}{r!}\\&amp;=(-1)^{r-1}\cdot\frac{1}{r2^{2r-1}}\binom{2r-2}{r-1} \end{align}\] so, \[(1+x)^\frac{1}{2} = \sum_{r=0}^{\infty}(-1)^{r-1}\frac{1}{r2^{2r-1}}\binom{2r-2}{r-1}x^r\] \(\binom{n}{r}\) 的一些基本性质: 对称 递推关系 单峰(中间最大) 可以看做在杨辉三角中, 从顶点走到\(\binom{n}{r}\) 点的所有路径数. 恒等式: \(\binom{n}{0} + \binom{n}{1} + \ldots + \binom{n}{n} = 2^n\) \(\binom{n}{i}\) 所有偶数项求和等于所有奇数项 \(1\binom{n}{1} + 2\binom{n}{2} + 3\binom{n}{3} + \ldots + n\binom{n}{n} = n2^{n-1}\), 证明: \((1+x)^n\) 在 \(x=1\) 处求导. \(\sum_{k=0}^{n}\binom{n}{k}^2 = \binom{2n}{n}\) \(\binom{0}{k}+\binom{1}{k} + \ldots + \binom{n}{k} = \binom{n+1}{k+1}\), 组合意义, \(\sum_{k=0}^{n}\binom{n}{k}^2 = \binom{n}{0}\binom{n}{n} + \binom{n}{1}\binom{n}{n-1} + \ldots + \binom{n}{n}\binom{n}{0}= \binom{2n}{n}\), 组合意义 \(\sum_{i=0}^{r}\binom{m}{i}\binom{n}{r-i} = \binom{m+n}{r}\) , Vandermonde 恒等式, 上式的推广 \(\sum_{i=0}^{m}\binom{m}{i}\binom{n}{r+i} = \binom{m+n}{m+r}\), 多项式定理 \((x_1+ x_2+ \ldots + x_t)^n = \sum\binom{n}{n_1n_2\ldots n_t}x_1^{n_1}x_2^{n_2}\ldots x_t^{n_t}\) 多项式系数 \(\binom{n}{n_1n_2\ldots n_t} = \frac{n!}{n_1!n_2!\ldots n_t!}\) 容斥定理 \(S\) 是有限集合, \(P_1 ,P_2,\ldots,P_m\) 是有关 \(S\) 元素的性质, \(A_i\) 是 \(S\) 中具有 \(P_i\) 性质的元素组成的集合, 则 \(S\) 中不具有性质 \(P_1,\ldots,P_m\) 的元素个数为: \[ |\overline{A_1} \cap \overline{A_2} \cap \ldots \cap \overline{A_m}| = |S| - \sum|A_i| + \sum|A_i\cap A_j| - \sum|A_i\cap A_j \cap A_k| + \ldots + (-1)^m |A_1\cap A_2 \cap \ldots \cap A_m|\] 错排问题 1,2,…,n, 的一个错排指满足每个数不在原位置的全排列. 错排数\(D_n = n!(1 - \frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+\ldots+(-1)^n\frac{1}{n!})\) 证明方法1. 容斥定理 $P_i $ 为 i 在原位置上. 2. 递推公式 有禁止模式的排列问题 容斥原理, \(P_i\) 为有某个禁止模式的排列 生成函数 定义 \(A(x) = a_0 + a_1x + a_2x^2 + \ldots\) 为序列 \(a_0, a_1, a_2, \ldots\) 的生成函数. 加法, 对应项相加 \(A(x)+B(x) \equiv \sum_{k=0}^\infty (a_k + b_k)x^k\) 乘法, 相乘后合并同次项 \(A(x)B(x) \equiv \sum_{k=0}^{\infty} (a_kb_0+a_{k-1}b_1+ \ldots + a_0b_k)x^k\) 加法零元: 0, 0, 0, … 乘法单位元: 1, 0, 0, … 形式多项式集合 \(R[[x]]\) 构成一个整环. 求导 生成函数的性质 一些计算规则和例子 \(b_k = \sum_{i=0}^k a_i\) \(\iff\) \(B(x) = \frac{A(x)}{1-x}\) \(b_k=\sum_{i=k}^\infty a_i \iff B(x) = \frac{A(1)-xA(x)}{1-x}\) \(b_k = ka_k \iff B(x) = xA&#39;(x)\) \(b_k=\frac{a_k}{k+1} \iff B(x) = \frac{1}{x}\int_0^xA(t)\,\mathrm{d}t\) 组合型分配问题的生成函数 \(\{\infty a_1, \infty a_2, \ldots, \infty a_n\}\), 的 \(k\) 组合数 其生成函数 \(A(x) = (\sum_{i=0}^\infty x^i )^n\) , 每个因子 \(\sum_{i=0}^\infty x^i\) 表示一个 a_i 可取的个数, 生成函数的 \(k\) 次项就是 \(k\) 组合数. \(A(x) = \frac{1}{(1-x)^n}\), \(a_k = \binom{n-1+k}{k}\) 排列型分配问题的指数型生成函数 指数型生成函数. 数列 \(a_i\), 的指数型生成函数为 \(\sum_{k=0}^\infty a_k \frac{x^k}{k!}\) 正整数拆分 递推关系 常系数线性齐次递推关系 常系数线性非齐次 迭代归纳法 生成函数求解递推关系 特殊计数序列 fibonacci catalan 集合划分 stirling 分配问题 Polya 计数 群 非空集合\(G\) 以及在上面的二元运算 \(\cdot\), 满足以下条件 运算封闭 结合律成立 存在单位元 每个元素都存在逆元 则称 \(\langle G, \cdot \rangle\) 为群. 由以上几条,可以证明的一些性质: 设\(\langle G, \cdot \rangle\) is a group, \(e\) is the identity element. then: \(e^{-1} = e\) \(e\) is unique 消去律成立, if \(a \cdot b = a \cdot c\) or \(b \cdot a = c \cdot a\) then \(b = c​\) \((a \cdot b)^{-1} =b^{-1} \cdot a^{-1}\) 定义子群, 设 \(\langle G, \cdot \rangle\) is a group, and \(H\) is a non-empty subset of \(G\), if \(\langle H, \cdot \rangle\) is a group, we call it \(G\)’s subgroup 一些性质包括, 只要 \(H\) 中运算封闭, \(\langle H, \cdot \rangle\) 就是子群. 置换群 有限集合\(D\) 上的 一一映射 成为 \(D\) 上的置换. 不失一般性, \(D=\{1,2,\ldots, n\}\) 一个置换 \(\sigma = \left ( \begin{array}{cccc}1&amp;2 &amp;\ldots &amp; n\\ \sigma(1) &amp;\sigma(2) &amp;\ldots &amp; \sigma(n)\end{array} \right )\) 将1 映射到 \(\sigma(1)\), 以此类推. \(D = \{1, 2,\ldots, n\}\) 的所有置换构成一个群, 记为\(S_n\), \(\big|S_n\big| = n!\) \((1,4,6)\) 这种叫轮换, \(1\to4, 4\to 6, 6 \to 1\), 其他不变. 举个例子, 轮换的复合运算: \((1234)(1234) = (13)(24)\) 任意置换都可以表示为不相交的轮换之积. \(D\) and \(R\) are two finite sets, \(F = D \to R\), \(G\) is a Permutation Group on D, for some \(f1_1, f_2 \in F\), if there exists \(\sigma \in G\), s.t. forall \(d \in D\), \[ f_1(d) = f_2(\sigma(d))\] We call \(f_1\) and \(f_2\) are \(G\) equal (\(G\) 等价) 两个映射 \(f_1\), \(f_2\) 在 置换群\(G\) 上等价, 如果存在一个定义域上的一一映射, 把定 义域的元素用这个映射换一下 \(f_1\) 就是 \(f_2\). 显然这个关系是\(F\) 上的一个等价关系 (和 \(G\) 好像并没有什么关系)? 并不是和\(G\) 没有关系哟. 如果给定一个置换群G, 那么就能把 \(F, (F = D \to R)\) 划分成 多个等价类. 对应到组合问题中, 比如一个着色方案, 一个分配方案, 实际上就是一个\(F = D \to R\), 着色方案的话, \(D\) 是定点, \(R\) 是颜色. 分配方案的话, \(D\) 是小球, \(R\) 是盒子. 给定一个置换群\(G\), 等价类的个数就是实际的组合方案数. Burnside 引理 定义两个置换的共轭: \(G\) is subgroup of \(S_n\), two elements \(s, t \in S_n\), if there exists a \(g \in G\), s.t. $s = g^{-1} t g $, then we say \(s\) is a conjugate of \(t\), and that viceversa, or \(s\) and \(t\) of \(G\) are conjugate. G-conjugate, G共轭是 \(S_n\) 上的一个等价关系. G共轭当且仅当, 两个置换是同型的. 定义同型: 映射的等价类 Burnside引理 可以解决用m色对n个物体着色的方案计数问题, 但是计算量太大, 经过 Polya 改进形成 Polya 计数定理后才得到广泛应用. 组合设计]]></content>
  </entry>
  <entry>
    <title><![CDATA[randomized algorithm]]></title>
    <url>%2F2017%2F12%2F11%2Frandomized-algorithm%2F</url>
    <content type="text"><![CDATA[概率算法 总结 基本概念 确定算法的平均执行时间: 一定输入规模的所有输入实例等概率出现时, 平均时间. 概率算法期望执行时间: 在某一个输入实例上的期望时间 概率算法的平均期望时间: 所有输入实例等概率的期望时间 概率算法的最坏期望时间: 最坏的输入实例上的期望时间 概率算法分类 Numerical 数值积分 Monte Carlo 给出一个答案，未必正确 Las Vegas 答案必定正确，耗时任意长, 可能_没有答案_. 比如吧 MenteCarlo 算法反复执行, 直至正确. Sherwood 总是给出正确的答案, 把一个确定性算法随机化, 可以降低算法的最坏时间复杂度 数值积分 HitorMiss 算法 面积法, 长方形下函数面积 在长方形区域取样, 计算有多少比例的点在函数下. Crude 算法 积分区间函取值的平均. 梯形积分 概率計数 求集合的勢 设 \(|X| = n\) , 有放回地随机抽元素, 设 \(k\) 是出现第一次重复之前所选的元素数目. 则当 \(n\) 足够大时, \(k\) 的期望趋近于 \(\beta \sqrt{n}\) , \(\beta = \sqrt{\pi / 2} \approx 1.253\) \(\beta\sqrt{n} = k\), 时间复杂度 \(\Theta(\sqrt{n})\) , 空间复杂度 \(\Theta(\sqrt{n})\). 向量中不同对象数目的估计 例如,磁带上记录有莎士比亚全集, 统计其中使用了多少不同的单词. \(N\) 是总单词书, \(n\) 是不同词个数. 设 \(U\) 是单词序列的集合, 设 \(m = 5 + \lceil lg M \rceil\) let \(h : U \mapsto \{0,1\}^m\) be a hash function. 将单词映射为长度为 \(m\) 的串. \(y \in \{0,1\}^k\), \(y[i]\) denotes the \(i\)th bit. Define $ (y, b), b{0,1}$ 表示满足 \(y[i] = b\) 的最小的 \(i\), 如果不存在, 返回 \(k+1\) 算法 WordCount() 用一个长为 \(m+1\) 的向量 \(y\) 统计所有单词的哈希. 单词 \(x\), set \(y[\pi(h(x), 1)]\) to 1 ==TODO== 时间 \(O(n)\) , 空间 \(O(\lg{}n)\) Sherwood 算法 Sherwood 算法, 平滑不同输入实例的执行时间. 把一个确定性算法随机化, 可以降低算法的最坏时间复杂度. 一般 Sherwood 算法的组成: 将输入变换到一个随机实例 用确定算法得到随机实例的解 将随机实例的解变换回原输入的解 例如快排 , 在特定输入下时间复杂度\(O(n^2)\), 可以吧把输入变换到一个随机实例上. 例: 离散对数的计算. ​ $ a = g^x p$ , 已知p, g, a, 求 x, 记为 \(\log_{g,p} a\) 确定算法: \(\forall x \in \mathbb{Z}_p\) 计算所有的 \(g^x\) 与 a 比较. 最坏为 \(O(p)\) 例: 搜索有序表.找x 随机找一个开始. 如果大于 x, 重来, 如果小于 x, 从这里开始顺序查找. 找 (前) \(\sqrt{n}\) 个元素, 从小于 x 且最接近 x 的开始顺序查找. (对有序表的数据结构有要求) Las Vegas 算法 时间上界可能不存在, (像扔硬币, 如果结果不是正面就再扔). 假设 try(x) 成功的概率为 p(x), 成功的期望时间s(x), 失败时期望时间e(x) 123obstinate() &#123; while (!try(x))&#125; obstinate(x) 一定会成功, 设期望时间为t(x) \(t = ps + (1-p)(e+t)\) \(t = s + \frac{1-p}{p}e\) 八皇后 模 p 平方根 说实话, 课程PPT 实在是太糟糕了. 定义 \(p\) is an (odd?, in course PPT, no problem, only ‘2’ is even) prime, if \(x \in [1, p-1]\), and for some y, \[ x = y^2 \mod p\] x is a quadratic residue modulo \(p\), and y is the square root of x. wiki: an interger \(q\) is called a quadratic reside modulo \(n\) if it is congruent to a perfect square module \(n\) Theorem: every quadratic residue module \(p\) has at least two different square root. proof: easy, if \(x_0^2 = y \mod p\) then \((p-x_0)^2 = y \mod p\). Theorem: every quadratic residue module \(p\) has at most two different square root. proof: \[ \begin{align} a^2 = b^2 \mod p \\ a^2 - b^2 \mod p \\ p | (a+b) (a-b) \\ \end{align} \] Theorem: half of \(\{1,2,\ldots, p-1\}\), is quadratic residue module \(p\). proof: every quadratic residue modulo \(p\) has two square root, [1, p-1] (f x : x*x maps two from range to one in the image, and no overlap) I’ll just write \(=_p\) instead of \(\mod p\) Theorem \(p\) is an odd prime, \(x^{(p-1)/2} =_p \pm 1\) and \(x\) is a quadratic residue modulo \(p\) iff !!! PPT error!! Maybe its: \(x^{(p-1)/2} =_p \pm 1\) iff \(x\) is a quadratic residue modulo \(p\)? I think so. proof by \(x^{(p-1)} =_p 1\), the Fermat Theorem This can be used to check if a number is a quadratic residue. Question: How to compute \(x\)’s square roots given it is a quadratic residue? if \(p = 3 \mod 4\), they are \(\pm x^{(p+1)/4}\) if \(p = 1 \mod 4\), there is no effeient determinat algorithm Las Vegas algorithm: We use \(\sqrt{x}\) to denotes the smaller one of its square roots TODO 整数因数分解 \(n\), 求 \(n = p_1^{m_1} p_2^{m_2} \ldots p_k^{m_k}\) 首先是素数判定, prime(n), 如果是合数, split(n), 找到 \(n\) 的一个非平凡因数. naive way to to split. test all number from 2 to \(\sqrt{x}\). Dixon 这里我们把 二次剩余, quadratic residue 推广到合数. 一个模 \(p\) 的二次剩余, 当 \(p\) 为素数时, 恰好有两个不同的平方根; 当 \(p\) 为合数, 且至少有**两个奇素数因子时, 不是这样. 例如 \(8^2 = 13^2 = 22^2 = 27^2 = 29 \mod 35\) Theorem: If \(x\) is a quadratic residue of \(q\), then \(x\) and \(q\) are relatively prime Theorem: If \(n= pq\), \(p\) and \(q\) are two different primes, then every quadratic residue of \(n\) has exactly 4 square roots. 素数测定 ​ Monte Carlo 算法 Monte Carlo 算法偶尔会犯错, 但无论对何实例都能以高概率找到正确解(?), 当算法出错时, 没有警告信息. Def 设 \(p \in (\frac{1}{2}, 1)\) if an MC algorithm 以不小于 p 的概率返回一个正确解, 则该MC算法称为 p-正确. 算法的优势(advantage) 为 \(p - \frac{1}{2}\) Def 若一个MC 算法对同一个实例不会给出两个不同的正确解, 则称该算法为 consistent. Def 偏真算法, 设 MC(x) 为一个解判定问题的算法. 对于任何 x, 如果 MC(x) 返回 true 时 永远是正确的, 返回 false 时 可能是错的. Def 偏\(y_0\)算法, 更一般的, 返回结果是 \(y_0\) 就肯定是对的. 主元素问题 参考 中科大算法分析与设计的总结 | 百度文库]]></content>
  </entry>
  <entry>
    <title><![CDATA[Write a Parser in OCaml]]></title>
    <url>%2F2017%2F06%2F25%2Fparser-in-OCaml%2F</url>
    <content type="text"><![CDATA[First we define the language, then translate it into OCaml code. Definition Two part is necessary, 1. Syntax Definition in Bacus-Naur Form to define the “Language”(which is, set of string). 2. And sematics definition to Describe the “Meaning”. Syntax Definition Including lexing and parsing rules. 123&lt;start&gt; ::= &lt;exp&gt; &apos;\n&apos;&lt;exp&gt; ::= &lt;exp&gt; &lt;op&gt; &lt;exp&gt; | [&quot;0&quot;-&quot;9&quot;]+&lt;op&gt; ::= &quot;+&quot; | &quot;-&quot; Sematics Definition This is the AST(Abstract Syntax Tree) definition, sine we want to write a frontend for a compiler. 12type op = Plus | Minus type exp = Exp of exp * op * exp | Num of int Implementation We need to implement four parts part file method lexer lexer.mll ocamllex parser parser.mly ocamlyacc AST ast.ml by hand, some lib for pretty printing driver driver.ml by hand Translate language definition to code In our Bacus-Naur Form definition, those symbols quoted with ' &quot; should be denoted as Lexeme simble. and defined in the parser.mly file. 123&lt;start&gt; ::= &lt;exp&gt; &apos;\n&apos;&lt;exp&gt; ::= &lt;exp&gt; &lt;op&gt; &lt;exp&gt; | [&apos;0&apos;-&apos;9&apos;]+&lt;op&gt; ::= &quot;+&quot; | &quot;-&quot; \(\Downarrow\) 123456789// regular grammar&lt;EOL&gt; ::= &apos;\n&apos;&lt;NUM&gt; ::= [&apos;0&apos;-&apos;9&apos;]+&lt;PLUS&gt; ::= &quot;+&quot;&lt;MINUS&gt; ::= &quot;-&quot;// context free grammar&lt;start&gt; ::= &lt;exp&gt; &lt;EOL&gt;&lt;exp&gt; ::= &lt;exp&gt; &lt;op&gt; &lt;exp&gt; | &lt;NUM&gt;&lt;op&gt; ::= &lt;PLUS&gt; | &lt;MINUS&gt; Regular grammar tokens are defined in the header of parser.mly, like this 1234%token &lt;int&gt; NUM%token PLUS MINUS%token EOL%left PLUS MINUS and produced by lexer.mll, like this 1234567rule token = parse [&apos; &apos; &apos;\t&apos;] &#123; token lexbuf &#125; | &apos;\n&apos; &#123; Parser.EOL&#125; | [&apos;0&apos;-&apos;9&apos;]+ as i &#123; Parser.NUM(int_of_string i) &#125; | &apos;+&apos; &#123; Parser.PLUS &#125; | &apos;-&apos; &#123; Parser.MINUS &#125; | eof &#123; raise Eof &#125; Context free grammar are put in the main part of the parser.mly The AST part can be put in the ast.ml file directly. Some utility function for error handling and pretty printing can be put here.]]></content>
  </entry>
  <entry>
    <title><![CDATA[始まりの物語]]></title>
    <url>%2F2017%2F03%2F01%2F%E5%A7%8B%E3%81%BE%E3%82%8A%E3%81%AE%E7%89%A9%E8%AA%9E%2F</url>
    <content type="text"><![CDATA[博客 引擎 Hexo, markdown 生成静态网页，轻松部署到 Github。 主题 NexT 评论 disqus, 多说评论挂了，Disqus 需要翻墙。 Markdown 功能测试 H3 H4 H5 H6 基本 markup normal ita ita bold underscores, strikethrough jump to google item item li li a * b, a_b , a\b 数学公式 MathJax Ref inline formulas: $a = \sum_{i=1}^{n} x_i$ \(a = \sum_{i=1}^{n} x_i\) displayed formulas: $$ \alpha ::= \tau \times \lambda $$ \[ \alpha ::= \tau \times \lambda \] Warning! 默认 markdown 编译器是 hexo-renderer-marked, 对于\\ * _ 的翻译有 bug, BUG: 混合 _ and $ 1$a_1, a_2$ \(a_1, a_2\) 1$a_0 a_&#123;n-1&#125;$ \(a_0 a_{n-1}\) 换一个renderer，在 hexo 插件页上有几个选择。 hexo-renderer-pandoc, 没问题了。 还有一个 hexo-renderer-markdown-it, 没试. 1$a\_0 a\_&#123;n - 1&#125; $ $a_0 a_{n - 1} $ \(a\_0\) Tables Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码 incline code 12345678(* invariant: *)(* x,y = exgcd(a,b) *)(* ax + by = gcd(a,b) *) let rec exgcd(a,b) : int * int = if a mod b = 0 then 0, 1 else let x,y = exgcd(b, a mod b) in y, x - y * (a/b);;]]></content>
      <tags>
        <tag>self-referencing</tag>
      </tags>
  </entry>
</search>
