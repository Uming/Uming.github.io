<!DOCTYPE html>
<html>
  <head>
    
    
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  randomized algorithm &ndash; BLTBLG

    </title>
    
    
    <meta name="description" property="og:description" content="概率算法 总结
|Describe what your web page is about">
    

    <meta name="apple-mobile-web-app-title" content="BLTBLG">
    
    
    <link rel="icon" href="/favicon-64.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="mask-icon" size="any" href="/pinned-icon.svg">
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@reveriel">
    <meta name="twitter:creator" content="@reveriel">
    <meta name="twitter:title" content="randomized algorithm | BLTBLG">
    <meta name="twitter:description" content="概率算法

总结|Describe what your web page is about">
    <meta name="twitter:image" content="http://reveriel.com/twitter-card.png">
    


    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">


      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">randomized algorithm</div>
  </div>
  <div class="Subhead-description">
    






    
    <div class="float-md-right">
      <span title="Lastmod: 2018-01-08. Published at: 2017-12-11.">
        
          Lastmod: 2018-01-08
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <h1 id="概率算法">概率算法</h1>

<p>总结</p>

<h2 id="基本概念">基本概念</h2>

<ul>
<li>确定算法的平均执行时间: 一定输入规模的所有输入实例等概率出现时, 平均时间.</li>
<li>概率算法期望执行时间: 在某一个输入实例上的期望时间</li>
<li>概率算法的平均期望时间: 所有输入实例等概率的期望时间</li>
<li>概率算法的最坏期望时间: 最坏的输入实例上的期望时间</li>
</ul>

<h2 id="概率算法分类">概率算法分类</h2>

<ul>
<li>Numerical

<ul>
<li>数值积分</li>
</ul></li>
<li>Monte Carlo

<ul>
<li>给出一个答案，未必正确</li>
</ul></li>
<li>Las Vegas

<ul>
<li>答案必定正确，耗时任意长, 可能<em>没有答案</em>. 比如吧 MenteCarlo 算法反复执行, 直至正确.</li>
</ul></li>
<li>Sherwood

<ul>
<li>总是给出正确的答案, 把一个确定性算法随机化, 可以降低算法的最坏时间复杂度</li>
</ul></li>
</ul>

<h2 id="数值积分">数值积分</h2>

<ul>
<li>HitorMiss 算法

<ul>
<li>面积法, 长方形下函数面积</li>
<li>在长方形区域取样, 计算有多少比例的点在函数下.</li>
</ul></li>
<li>Crude 算法

<ul>
<li>积分区间函取值的平均.</li>
</ul></li>
<li>梯形积分</li>
</ul>

<h2 id="概率計数">概率計数</h2>

<h3 id="求集合的勢">求集合的勢</h3>

<p>设 $|X| = n$ , 有放回地随机抽元素, 设 $k$ 是出现第一次重复之前所选的元素数目. 则当 $n$ 足够大时, $k$ 的期望趋近于 $\beta \sqrt{n}$ ,</p>

<p>$\beta = \sqrt{\pi / 2} \approx 1.253$</p>

<p>$\beta\sqrt{n} = k$,</p>

<p>时间复杂度 $\Theta(\sqrt{n})$ , 空间复杂度 $\Theta(\sqrt{n})$.</p>

<h3 id="向量中不同对象数目的估计">向量中不同对象数目的估计</h3>

<p>例如,磁带上记录有莎士比亚全集, 统计其中使用了多少不同的单词. $N$ 是总单词书, $n$ 是不同词个数.</p>

<p>设 $U$ 是单词序列的集合, 设 $m = 5 + \lceil lg M \rceil$</p>

<p>let $h : U \mapsto {0,1}^m$ be a hash function. 将单词映射为长度为 $m$ 的串.</p>

<p>$y \in {0,1}^k$,  $y[i]$ denotes the $i$th bit.</p>

<p>Define $ \pi(y, b), b\in {0,1}$  表示满足 $y[i] = b$ 的最小的 $i$, 如果不存在, 返回 $k+1$</p>

<p>算法 WordCount() 用一个长为 $m+1$ 的向量 $y$ 统计所有单词的哈希.
单词 $x$,  set $y[\pi(h(x), 1)]$ to 1</p>

<p>==TODO==</p>

<p>时间 $O(n)$ , 空间 $O(\lg{}n)$</p>

<h2 id="sherwood-算法">Sherwood 算法</h2>

<p>Sherwood 算法, 平滑不同输入实例的执行时间. 把一个确定性算法随机化, 可以降低算法的最坏时间复杂度.</p>

<p>一般 Sherwood 算法的组成:</p>

<ol>
<li>将输入变换到一个随机实例</li>
<li>用确定算法得到随机实例的解</li>
<li>将随机实例的解变换回原输入的解</li>
</ol>

<p>例如快排 , 在特定输入下时间复杂度$O(n^2)$, 可以吧把输入变换到一个随机实例上.</p>

<p><strong>例</strong>: 离散对数的计算.</p>

<p>​    $ a = g^x \mod p$ , 已知p, g, a, 求 x,  记为 $\log_{g,p} a$</p>

<p>确定算法:  $\forall x \in \mathbb{Z}_p$ 计算所有的 $g^x$ 与 a 比较. 最坏为 $O(p)$</p>

<p><strong>例</strong>: 搜索有序表.找x</p>

<p>随机找一个开始. 如果大于 x, 重来, 如果小于 x, 从这里开始顺序查找.</p>

<p>找 (前) $\sqrt{n}$ 个元素, 从小于 x 且最接近 x 的开始顺序查找. (对有序表的数据结构有要求)</p>

<h2 id="las-vegas-算法">Las Vegas 算法</h2>

<p>时间上界可能不存在, (像扔硬币, 如果结果不是正面就再扔).</p>

<p>假设 try(x) 成功的概率为 p(x), 成功的期望时间s(x), 失败时期望时间e(x)</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">obstinate</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">try</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="p">}</span></code></pre></div>
<p>obstinate(x) 一定会成功, 设期望时间为t(x)</p>

<p>$t = ps + (1-p)(e+t)$</p>

<p>$t = s + \frac{1-p}{p}e$</p>

<h3 id="八皇后">八皇后</h3>

<h3 id="模-p-平方根">模 p 平方根</h3>

<p>说实话, 课程PPT 实在是太糟糕了.</p>

<p>定义 $p$ is an (odd?, in course PPT, no problem, only &lsquo;2&rsquo; is even) prime,
 if $x \in [1, p-1]$, and for some y,</p>

<p>$$ x = y^2 \mod p$$</p>

<p>x is a <em>quadratic residue</em> modulo $p$, and y is the square root of x.</p>

<blockquote>
<p>wiki: an interger $q$ is called a <em>quadratic reside</em> modulo $n$ if it is congruent
to a perfect square module $n$</p>
</blockquote>

<p><strong>Theorem</strong>: every quadratic residue module $p$ has at least two different square
root.</p>

<p>proof: easy, if $x_0^2 = y \mod p$ then $(p-x_0)^2 = y \mod p$.</p>

<p><strong>Theorem</strong>: every quadratic residue module $p$ has at most two different square root.</p>

<p>proof:</p>

<p>$$
\begin{align}
a^2 = b^2 \mod p <br />
a^2 - b^2 \mod p <br />
 p | (a+b) (a-b) <br />
 \end{align}
$$
<strong>Theorem</strong>:  half of ${1,2,\ldots, p-1}$, is quadratic residue module $p$.</p>

<p>proof: every quadratic residue modulo $p$ has two square root,</p>

<p><a href="f x : x*x maps two from range to one in the image, and no overlap">1, p-1</a></p>

<blockquote>
<p>I&rsquo;ll just write $=_p$ instead of $\mod p$</p>
</blockquote>

<p><strong>Theorem</strong>  $p$ is an odd prime, $x^{(p-1)/2} =_p \pm 1$ and $x$ is a
quadratic residue modulo $p$ iff  !!! PPT error!!</p>

<p>Maybe its:  $x^{(p-1)/2} =_p \pm 1$ iff $x$ is a quadratic residue modulo $p$?
I think so. proof by  $x^{(p-1)} =_p 1$, the Fermat Theorem</p>

<p>This can be used to check if a number is a quadratic residue.</p>

<p><strong>Question</strong>: How to compute $x$&rsquo;s square roots given it is a quadratic residue?</p>

<ul>
<li>if $p = 3 \mod 4$, they are $\pm x^{(p+1)/4}$</li>
<li>if $p = 1 \mod 4$, there is no effeient determinat algorithm</li>
</ul>

<p>Las Vegas algorithm:</p>

<p>We use $\sqrt{x}$ to denotes the smaller one of its square roots</p>

<p style="color:red">TODO</p>

<h3 id="整数因数分解">整数因数分解</h3>

<p>$n$,   求 $n = p_1^{m_1} p_2^{m_2} \ldots p_k^{m_k}$</p>

<p>首先是素数判定, prime(n), 如果是合数, split(n), 找到 $n$ 的一个非平凡因数.</p>

<h4 id="naive-way-to-to-split">naive way to to split.</h4>

<p>test all number from 2 to $\sqrt{x}$.</p>

<h4 id="dixon">Dixon</h4>

<p>这里我们把 二次剩余, quadratic residue 推广到合数.</p>

<p>一个模 $p$ 的二次剩余, 当 $p$ 为素数时, 恰好有两个不同的平方根; 当 $p$ 为合数, 且至少有**两个奇素数因子时, 不是这样. 例如 $8^2 = 13^2 = 22^2 =  27^2 = 29 \mod 35$</p>

<p><strong>Theorem</strong>: If $x$ is a quadratic residue of $q$, then  $x$ and $q$ are
relatively prime</p>

<p><strong>Theorem</strong>: If $n= pq$, $p$ and $q$ are two different primes, then every quadratic
residue of $n$ has exactly 4 square roots.</p>

<h3 id="素数测定">素数测定</h3>

<ul>
<li>​</li>
</ul>

<h2 id="monte-carlo-算法">Monte Carlo 算法</h2>

<p>Monte Carlo 算法偶尔会犯错, 但无论对何实例都能以高概率找到正确解(?), 当算法出错时, 没有警告信息.</p>

<p><strong>Def</strong>  设 $p \in (\frac{1}{2}, 1)$ if an MC algorithm 以不小于 p 的概率返回一个正确解, 则该MC算法称为 p-正确. 算法的优势(advantage) 为 $p - \frac{1}{2}$</p>

<p><strong>Def</strong> 若一个MC 算法对同一个实例不会给出两个不同的正确解, 则称该算法为 consistent.</p>

<p><strong>Def</strong> <strong>偏真算法</strong>, 设 MC(x) 为一个解判定问题的算法. 对于任何 x, 如果 MC(x) 返回 true 时 永远是正确的, 返回 false 时 可能是错的.</p>

<p><strong>Def</strong> <strong>偏$y_0$算法</strong>, 更一般的, 返回结果是 $y_0$ 就肯定是对的.</p>

<h3 id="主元素问题">主元素问题</h3>

<h1 id="参考">参考</h1>

<p><a href="https://wenku.baidu.com/view/26caaadb50e2524de5187ed0.html">中科大算法分析与设计的总结 | 百度文库</a></p>
  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>randomized algorithm</b>
      <nav id="TableOfContents">
<ul>
<li><a href="#概率算法">概率算法</a>
<ul>
<li><a href="#基本概念">基本概念</a></li>
<li><a href="#概率算法分类">概率算法分类</a></li>
<li><a href="#数值积分">数值积分</a></li>
<li><a href="#概率計数">概率計数</a>
<ul>
<li><a href="#求集合的勢">求集合的勢</a></li>
<li><a href="#向量中不同对象数目的估计">向量中不同对象数目的估计</a></li>
</ul></li>
<li><a href="#sherwood-算法">Sherwood 算法</a></li>
<li><a href="#las-vegas-算法">Las Vegas 算法</a>
<ul>
<li><a href="#八皇后">八皇后</a></li>
<li><a href="#模-p-平方根">模 p 平方根</a></li>
<li><a href="#整数因数分解">整数因数分解</a>
<ul>
<li><a href="#naive-way-to-to-split">naive way to to split.</a></li>
<li><a href="#dixon">Dixon</a></li>
</ul></li>
<li><a href="#素数测定">素数测定</a></li>
</ul></li>
<li><a href="#monte-carlo-算法">Monte Carlo 算法</a>
<ul>
<li><a href="#主元素问题">主元素问题</a></li>
</ul></li>
</ul></li>
<li><a href="#参考">参考</a></li>
</ul>
</nav>
    </div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    
  </span>


      </div>
    </div>


    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
  </body>
</html>
